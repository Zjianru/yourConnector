<!--
  文件职责：
  1. 定义移动端（Tauri WebView）调试与运维 UI 的结构、样式与交互。
  2. 维护与 relay 的 WebSocket 会话，并展示宿主机与工具快照。
  3. 提供候选工具接入、工具详情查看和调试日志入口。
-->
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>yourConnector Mobile</title>
    <style>
      :root {
        --bg-0: #040914;
        --bg-1: #0a1a2f;
        --bg-2: #0d223f;
        --glass: rgba(255, 255, 255, 0.08);
        --glass-strong: rgba(255, 255, 255, 0.14);
        --line: rgba(179, 217, 255, 0.28);
        --line-soft: rgba(179, 217, 255, 0.14);
        --text: #eaf4ff;
        --text-sub: #9eb8d7;
        --ok: #34d399;
        --warn: #fb923c;
        --accent: #38bdf8;
        --accent-2: #22d3ee;
        --card-soft: linear-gradient(160deg, rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.04));
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
      }

      body {
        font-family: "PingFang SC", "SF Pro Text", "Helvetica Neue", sans-serif;
        color: var(--text);
        background:
          radial-gradient(900px 500px at -10% -15%, rgba(56, 189, 248, 0.28), transparent 50%),
          radial-gradient(1000px 560px at 100% 110%, rgba(52, 211, 153, 0.18), transparent 48%),
          linear-gradient(145deg, var(--bg-0), var(--bg-1), var(--bg-2));
      }

      .app {
        max-width: 460px;
        margin: 0 auto;
        min-height: 100vh;
        padding: env(safe-area-inset-top, 14px) 14px calc(env(safe-area-inset-bottom, 14px) + 84px);
      }

      .topbar {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        margin-bottom: 12px;
      }

      .top-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .glass-card {
        background: var(--card-soft);
        border: 1px solid var(--line-soft);
        border-radius: 24px;
        box-shadow: 0 14px 42px rgba(0, 8, 26, 0.35);
        backdrop-filter: blur(16px);
      }

      .status-card {
        padding: 16px;
        margin-bottom: 16px;
      }

      .status-head {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--warn);
        box-shadow: 0 0 0 4px rgba(251, 146, 60, 0.2);
      }

      .status-dot.online {
        background: var(--ok);
        box-shadow: 0 0 0 4px rgba(52, 211, 153, 0.2);
      }

      .status-text {
        font-size: 18px;
        font-weight: 700;
      }

      .host-badge {
        margin-left: auto;
        color: var(--text-sub);
        font-size: 12px;
        border: 1px solid var(--line-soft);
        border-radius: 999px;
        padding: 4px 10px;
      }

      .status-sub {
        color: var(--text-sub);
        margin: 10px 0 12px;
        font-size: 12px;
      }

      .btn {
        border: 1px solid transparent;
        border-radius: 14px;
        padding: 11px 14px;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
      }

      .btn-sm {
        padding: 8px 11px;
        border-radius: 11px;
        font-size: 12px;
      }

      .btn:disabled {
        cursor: not-allowed;
        opacity: 0.46;
      }

      .btn-primary {
        color: white;
        background: linear-gradient(135deg, #0ea5e9, #2563eb);
      }

      .btn-outline {
        color: var(--text);
        border-color: var(--line);
        background: rgba(255, 255, 255, 0.04);
      }

      .section-title {
        margin: 18px 4px 10px;
        font-weight: 800;
        font-size: 20px;
      }

      .section-head {
        display: flex;
        align-items: center;
        margin: 18px 4px 6px;
      }

      .section-head .section-title {
        margin: 0;
      }

      .add-tool-btn {
        margin-left: auto;
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        font-size: 20px;
        line-height: 1;
        display: grid;
        place-items: center;
        cursor: pointer;
      }

      .section-sub {
        margin: 0 4px 10px;
        color: var(--text-sub);
        font-size: 12px;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .metric-card {
        padding: 14px;
        border-radius: 20px;
        border: 1px solid var(--line-soft);
        background: linear-gradient(160deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.05));
      }

      .metric-name {
        color: var(--text-sub);
        font-size: 12px;
        font-weight: 600;
      }

      .metric-value {
        margin-top: 7px;
        font-size: 24px;
        font-weight: 800;
      }

      .metric-sub {
        margin-top: 6px;
        color: var(--text-sub);
        font-size: 11px;
        line-height: 1.5;
      }

      .skeleton {
        position: relative;
        overflow: hidden;
      }

      .skeleton::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(120deg, transparent, rgba(255, 255, 255, 0.16), transparent);
        transform: translateX(-100%);
        animation: shine 1.2s infinite;
      }

      @keyframes shine {
        to {
          transform: translateX(100%);
        }
      }

      .tools {
        display: grid;
        gap: 12px;
      }

      .tool-card {
        border-radius: 24px;
        padding: 16px;
        border: 1px solid var(--line-soft);
        background: linear-gradient(165deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.04));
        cursor: pointer;
        transform: translateY(0);
        transition: transform 220ms ease, box-shadow 220ms ease, border-color 220ms ease;
      }

      .tool-card:hover {
        transform: translateY(-2px);
        border-color: var(--line);
        box-shadow: 0 18px 38px rgba(2, 10, 28, 0.35);
      }

      .tool-opencode {
        background:
          radial-gradient(120% 100% at 0% 0%, rgba(56, 189, 248, 0.24), transparent 55%),
          radial-gradient(100% 100% at 100% 100%, rgba(52, 211, 153, 0.22), transparent 48%),
          linear-gradient(145deg, #0f172a, #17243f, #0b1428);
      }

      .tool-head {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .tool-logo {
        width: 42px;
        height: 42px;
        border-radius: 12px;
        background: linear-gradient(135deg, #38bdf8, #34d399);
        display: grid;
        place-items: center;
        font-weight: 900;
        color: #01283b;
      }

      .tool-name {
        font-size: 20px;
        font-weight: 800;
      }

      .chip {
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        padding: 5px 10px;
        font-size: 11px;
        font-weight: 700;
      }

      .chip-wrap {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }

      .tool-note {
        margin-top: 11px;
        color: rgba(230, 242, 255, 0.82);
        font-size: 12px;
        line-height: 1.5;
      }

      .tool-metrics {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .tool-metric {
        border-radius: 13px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
      }

      .tool-metric .name {
        color: rgba(230, 242, 255, 0.74);
        font-size: 11px;
      }

      .tool-metric .value {
        margin-top: 3px;
        font-weight: 700;
      }

      .tool-generic {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .tool-generic .bar {
        width: 10px;
        height: 58px;
        border-radius: 999px;
        background: linear-gradient(180deg, #14b8a6, #22c55e);
      }

      .tool-generic .title {
        font-size: 17px;
        font-weight: 700;
      }

      .tool-generic .sub {
        color: var(--text-sub);
        font-size: 12px;
        margin-top: 4px;
      }

      .tool-generic .right {
        margin-left: auto;
        text-align: right;
      }

      .empty {
        padding: 14px;
        border-radius: 20px;
        border: 1px solid var(--line-soft);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text-sub);
        font-size: 13px;
      }

      .debug-panel {
        display: grid;
        gap: 8px;
      }

      .debug-stats {
        color: var(--text-sub);
        font-size: 13px;
        line-height: 1.45;
      }

      .field {
        display: grid;
        gap: 4px;
      }

      .field label {
        color: var(--text-sub);
        font-size: 12px;
      }

      .field input {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--line-soft);
        background: rgba(4, 15, 29, 0.66);
        color: var(--text);
        padding: 10px 12px;
        outline: none;
      }

      .field select {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--line-soft);
        background: rgba(4, 15, 29, 0.66);
        color: var(--text);
        padding: 10px 12px;
        outline: none;
      }

      .debug-actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .log-box {
        min-height: 240px;
        max-height: 320px;
        overflow: auto;
        border-radius: 14px;
        border: 1px solid var(--line-soft);
        background: rgba(2, 10, 20, 0.76);
        padding: 8px;
        font-family: "SF Mono", "Menlo", "Consolas", monospace;
        font-size: 11px;
        line-height: 1.45;
      }

      .log-item {
        color: #c7ddf5;
        padding: 4px 2px;
        border-bottom: 1px solid rgba(179, 217, 255, 0.08);
      }

      .tabs {
        position: fixed;
        left: 50%;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
        transform: translateX(-50%);
        width: min(430px, calc(100% - 24px));
        border: 1px solid var(--line-soft);
        background: rgba(4, 14, 26, 0.82);
        border-radius: 20px;
        backdrop-filter: blur(16px);
        box-shadow: 0 10px 30px rgba(0, 6, 20, 0.42);
        display: grid;
        grid-template-columns: 1fr 1fr;
        padding: 6px;
        z-index: 60;
      }

      .tab-btn {
        border: 0;
        border-radius: 14px;
        background: transparent;
        color: var(--text-sub);
        font-size: 13px;
        font-weight: 700;
        padding: 11px 10px;
        cursor: pointer;
      }

      .tab-btn.active {
        color: white;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.31), rgba(14, 165, 233, 0.25));
      }

      .view {
        display: none;
      }

      .view.active {
        display: block;
        animation: rise 260ms ease;
      }

      .ops-body.hidden {
        display: none;
      }

      .host-setup .field {
        margin-bottom: 8px;
      }

      .host-setup-tip {
        margin: 0 0 12px;
        color: var(--text-sub);
        font-size: 12px;
      }

      .host-preview {
        margin: 0 0 12px;
        display: grid;
        gap: 6px;
      }

      .host-preview-item {
        border-radius: 12px;
        border: 1px solid var(--line-soft);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px 11px;
      }

      .host-preview-item .name {
        color: var(--text-sub);
        font-size: 11px;
      }

      .host-preview-item .value {
        margin-top: 3px;
        font-size: 12px;
        line-height: 1.45;
        word-break: break-all;
      }

      .host-setup-actions {
        display: grid;
        gap: 8px;
      }

      .host-banner-track {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: 88%;
        gap: 10px;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        padding-bottom: 2px;
      }

      .host-banner-track::-webkit-scrollbar {
        display: none;
      }

      .host-banner-card {
        scroll-snap-align: center;
        border-radius: 20px;
        padding: 14px;
        border: 1px solid var(--line-soft);
        background:
          radial-gradient(120% 90% at 0% 0%, rgba(56, 189, 248, 0.18), transparent 55%),
          linear-gradient(168deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.05));
      }

      .host-banner-name {
        font-size: 18px;
        font-weight: 800;
      }

      .host-banner-status {
        margin-top: 6px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: #d9e9fb;
        font-size: 12px;
      }

      .host-status-light {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        flex: none;
      }

      .host-status-light.online {
        background: #22c55e;
        box-shadow: 0 0 10px rgba(34, 197, 94, 0.95);
      }

      .host-status-light.offline {
        background: #ef4444;
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.95);
      }

      .host-banner-dots {
        margin-top: 10px;
        display: flex;
        justify-content: center;
        gap: 8px;
      }

      .host-banner-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.46);
        transition: transform 180ms ease, opacity 180ms ease;
      }

      .host-banner-dot.active {
        background: rgba(255, 255, 255, 0.95);
        transform: scale(1.2);
      }

      .host-group {
        border-radius: 20px;
        border: 1px solid var(--line-soft);
        background: linear-gradient(160deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.04));
        padding: 14px;
      }

      .host-group-head {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .host-group-title {
        font-size: 16px;
        font-weight: 800;
      }

      .host-status-chip {
        margin-left: auto;
        border-radius: 999px;
        border: 1px solid var(--line-soft);
        padding: 4px 10px;
        color: var(--text-sub);
        font-size: 11px;
        font-weight: 700;
      }

      .host-group-actions {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }

      .host-group-tools {
        display: grid;
        gap: 10px;
      }

      .host-manage-list {
        display: grid;
        gap: 10px;
      }

      .host-manage-item {
        border-radius: 14px;
        border: 1px solid var(--line-soft);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px;
      }

      .host-manage-name {
        font-size: 15px;
        font-weight: 760;
      }

      .host-manage-sub {
        margin-top: 4px;
        color: var(--text-sub);
        font-size: 12px;
      }

      .host-manage-actions {
        margin-top: 9px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(2, 10, 20, 0.6);
        backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 14px;
        z-index: 90;
      }

      .modal.show {
        display: flex;
      }

      .modal-card {
        width: min(430px, 100%);
        max-height: 88vh;
        overflow: auto;
        border-radius: 26px;
        border: 1px solid var(--line);
        background:
          radial-gradient(90% 80% at 0% 0%, rgba(56, 189, 248, 0.16), transparent 55%),
          linear-gradient(170deg, #0a1425, #0f1f38);
        padding: 16px;
        box-shadow: 0 30px 70px rgba(0, 6, 20, 0.55);
      }

      .modal-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .modal-top h3 {
        margin: 0;
        font-size: 21px;
      }

      .icon-btn {
        width: 34px;
        height: 34px;
        border: 1px solid var(--line-soft);
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        font-size: 20px;
        display: grid;
        place-items: center;
        cursor: pointer;
      }

      .detail-card {
        margin-top: 10px;
        border-radius: 18px;
        border: 1px solid var(--line-soft);
        background: linear-gradient(170deg, rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.05));
        padding: 14px;
      }

      .candidate-list {
        display: grid;
        gap: 10px;
      }

      .candidate-item {
        border-radius: 14px;
        border: 1px solid var(--line-soft);
        background: rgba(255, 255, 255, 0.06);
        padding: 11px;
      }

      .candidate-head {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .candidate-title {
        font-size: 15px;
        font-weight: 760;
      }

      .candidate-actions {
        margin-left: auto;
      }

      .candidate-meta {
        margin-top: 8px;
        color: var(--text-sub);
        font-size: 12px;
        line-height: 1.45;
      }

      .detail-title {
        margin: 0 0 8px;
        font-size: 17px;
        font-weight: 800;
      }

      .rows {
        display: grid;
        gap: 7px;
      }

      .row {
        display: grid;
        grid-template-columns: 126px 1fr;
        gap: 6px;
        align-items: start;
      }

      .row .k {
        color: var(--text-sub);
        font-size: 12px;
      }

      .row .v {
        text-align: right;
        font-size: 13px;
        font-weight: 650;
        line-height: 1.45;
        word-break: break-word;
      }

      .expand-head {
        display: flex;
        align-items: center;
      }

      .expand-head .title {
        font-size: 17px;
        font-weight: 800;
      }

      .expand-head button {
        margin-left: auto;
      }

      .expand-tip {
        color: var(--text-sub);
        font-size: 12px;
        margin-top: 4px;
      }

      @media (max-width: 360px) {
        .row {
          grid-template-columns: 100px 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="topbar">
        <div class="top-actions">
          <button id="connectBtnTop" class="btn btn-primary btn-sm">连接全部宿主机</button>
          <button id="disconnectBtnTop" class="btn btn-outline btn-sm" disabled>断开全部</button>
          <button id="replaceHostBtnTop" class="btn btn-outline btn-sm">更换宿主机</button>
        </div>
      </header>

      <section id="opsView" class="view active">
        <article id="hostSetupCard" class="glass-card status-card host-setup">
          <h2 class="section-title" style="margin-top: 0">配对宿主机</h2>
          <p class="host-setup-tip">首次使用请先导入配对链接；无法扫码时可进入手动配对页填写 Relay 与配对码。</p>
          <div class="host-setup-actions">
            <button id="importPairLinkBtn" class="btn btn-primary">导入配对链接</button>
            <button id="openManualPairBtn" class="btn btn-outline">手动填写配对码</button>
            <button id="openDebugFromSetupBtn" class="btn btn-outline">打开调试入口</button>
          </div>
        </article>

        <div id="hostOverviewWrap" class="ops-body hidden">
          <article class="glass-card status-card">
            <h2 class="section-title" style="margin-top: 0">Host Snapshot</h2>
            <div id="hostBannerTrack" class="host-banner-track"></div>
            <div id="hostBannerDots" class="host-banner-dots"></div>
          </article>

          <div class="section-head">
            <h2 class="section-title">Connected Tools</h2>
          </div>
          <p class="section-sub">按宿主机分组展示每台宿主机已接入工具。</p>
          <div id="toolsGroupedList" class="tools"></div>
        </div>
      </section>

      <section id="debugView" class="view">
        <article class="glass-card status-card debug-panel">
          <div id="debugStatus" class="debug-stats">Status: Disconnected</div>
          <div id="debugEvents" class="debug-stats">Events IN: 0 · OUT: 0</div>

          <div class="field">
            <label for="debugHostSelect">调试宿主机</label>
            <select id="debugHostSelect"></select>
          </div>
          <div id="debugIdentity" class="debug-stats"></div>

          <div class="debug-actions">
            <button id="connectBtnDebug" class="btn btn-primary">连接当前宿主机</button>
            <button id="disconnectBtnDebug" class="btn btn-outline" disabled>断开当前宿主机</button>
          </div>
          <button id="rebindControllerBtn" class="btn btn-outline">
            绑定当前设备为控制端
          </button>

          <div class="field">
            <label for="messageInput">Test Message</label>
            <input id="messageInput" type="text" />
          </div>

          <button id="sendBtn" class="btn btn-primary">Send Test Event</button>

          <div class="field">
            <label>Logs</label>
            <div id="logBox" class="log-box"></div>
          </div>
        </article>
      </section>
    </div>

    <nav class="tabs">
      <button id="tabOps" class="tab-btn active">运维</button>
      <button id="tabDebug" class="tab-btn">调试入口</button>
    </nav>

    <div id="toolModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3 id="toolModalTitle">Tool Detail</h3>
          <button id="toolModalClose" class="icon-btn" aria-label="关闭">×</button>
        </div>

        <section class="detail-card">
          <h4 class="detail-title">OpenCode 摘要</h4>
          <div id="summaryRows" class="rows"></div>
        </section>

        <section class="detail-card">
          <div class="expand-head">
            <span class="title">更多信息</span>
            <button id="toggleDetailsBtn" class="icon-btn" aria-label="展开或收起">⌄</button>
          </div>
          <div id="detailRows" class="rows" style="margin-top: 8px"></div>
          <p id="detailTip" class="expand-tip"></p>
        </section>

        <section id="usagePanel" class="detail-card" style="display: none">
          <h4 class="detail-title">模型用量（当前会话）</h4>
          <div id="usageRows" class="rows"></div>
        </section>
      </div>
    </div>

    <div id="addToolModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3>添加 AI 工具</h3>
          <button id="addToolModalClose" class="icon-btn" aria-label="关闭">×</button>
        </div>

        <p class="section-sub" style="margin-top: 8px">
          这里展示 sidecar 自动发现但尚未接入白名单的候选工具，点击接入后才会出现在 Connected Tools。
        </p>

        <section class="detail-card">
          <h4 class="detail-title">候选工具</h4>
          <div id="candidateList" class="candidate-list"></div>
        </section>

        <section class="detail-card">
          <h4 class="detail-title">接入提示</h4>
          <div class="rows">
            <div class="row"><div class="k">OpenCode</div><div class="v">在宿主机终端执行 `opencode`，保持会话运行</div></div>
            <div class="row"><div class="k">OpenClaw</div><div class="v">按宿主机上的启动方式运行 openclaw，等待 sidecar 自动发现</div></div>
          </div>
        </section>

        <button id="goDebugFromAddTool" class="btn btn-outline" style="width: 100%">
          打开调试页查看连接参数
        </button>
      </div>
    </div>

    <div id="pairFlowModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3 id="pairFlowTitle">导入配对链接</h3>
          <button id="pairFlowClose" class="icon-btn" aria-label="关闭">×</button>
        </div>

        <section id="pairFlowStepImport" class="detail-card">
          <h4 class="detail-title">选择导入方式</h4>
          <p class="section-sub" style="margin: 0 0 12px">
            扫码与粘贴链接会在校验通过后直接配对并连接宿主机。
          </p>
          <div class="host-setup-actions">
            <button id="pairOpenScanBtn" class="btn btn-primary">导入/扫描二维码配对</button>
            <button id="pairOpenPasteBtn" class="btn btn-outline">粘贴配对链接以配对</button>
          </div>
        </section>

        <section id="pairFlowStepPaste" class="detail-card" style="display: none">
          <h4 class="detail-title">粘贴配对链接</h4>
          <div class="field">
            <label for="pairLinkInput">配对链接（yc://pair?...）</label>
            <input id="pairLinkInput" type="text" placeholder="粘贴扫码结果或 yc://pair 链接" />
          </div>
          <div class="host-setup-actions" style="margin-top: 10px">
            <button id="pairPasteSubmitBtn" class="btn btn-primary">配对并连接</button>
            <button id="pairPasteBackBtn" class="btn btn-outline">返回</button>
          </div>
        </section>

        <section id="pairFlowStepScan" class="detail-card" style="display: none">
          <h4 class="detail-title">扫码配对</h4>
          <p class="section-sub" style="margin: 0 0 8px">
            对准 sidecar/relay 展示的二维码，识别成功后将自动配对并连接。
          </p>
          <p id="pairScanStatus" class="section-sub" style="margin: 0 0 8px; min-height: 20px"></p>
          <div style="border: 1px solid var(--line-soft); border-radius: 14px; overflow: hidden; background: rgba(2, 10, 20, 0.76)">
            <video id="pairScanVideo" autoplay playsinline muted style="width: 100%; height: 220px; object-fit: cover"></video>
          </div>
          <input id="pairScanFileInput" type="file" accept="image/*" style="display: none" />
          <div class="host-setup-actions" style="margin-top: 10px">
            <button id="pairScanGalleryBtn" class="btn btn-outline">从图库导入二维码</button>
            <button id="pairScanBackBtn" class="btn btn-outline">返回</button>
          </div>
        </section>

        <section id="pairFlowStepManual" class="detail-card" style="display: none">
          <h4 class="detail-title">手动填写配对码</h4>
          <div class="field">
            <label for="hostRelayInput">Relay WS URL</label>
            <input id="hostRelayInput" type="text" />
          </div>
          <div class="field" style="margin-top: 8px">
            <label for="hostPairCodeInput">配对码（systemId.pairToken）</label>
            <input id="hostPairCodeInput" type="text" placeholder="例如 sys_xxx.ptk_xxx" />
          </div>
          <div class="field" style="margin-top: 8px">
            <label for="hostNameInput">宿主机名称（可修改）</label>
            <input id="hostNameInput" type="text" placeholder="例如 我的 MacBook Pro" />
          </div>
          <div class="host-setup-actions" style="margin-top: 10px">
            <button id="pairManualSubmitBtn" class="btn btn-primary">配对并连接</button>
            <button id="pairManualBackBtn" class="btn btn-outline">返回</button>
          </div>
        </section>
      </div>
    </div>

    <div id="pairFailureModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3>配对失败</h3>
          <button id="pairFailureClose" class="icon-btn" aria-label="关闭">×</button>
        </div>
        <section class="detail-card">
          <h4 id="pairFailureReason" class="detail-title" style="font-size: 16px">失败原因</h4>
          <p id="pairFailureSuggestion" class="section-sub" style="margin: 0">建议下一步</p>
          <div class="host-setup-actions" style="margin-top: 12px">
            <button id="pairFailurePrimaryBtn" class="btn btn-primary">重试</button>
            <button id="pairFailureSecondaryBtn" class="btn btn-outline">关闭</button>
          </div>
        </section>
      </div>
    </div>

    <div id="hostManageModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3>宿主机管理</h3>
          <button id="hostManageClose" class="icon-btn" aria-label="关闭">×</button>
        </div>
        <section class="detail-card">
          <h4 class="detail-title">已配对宿主机</h4>
          <div id="hostManageList" class="host-manage-list"></div>
        </section>
        <section class="detail-card">
          <h4 class="detail-title">删除补偿队列</h4>
          <p class="section-sub" style="margin: 0 0 8px">Relay 不可达时会先隐藏宿主机并进入补偿队列，恢复连通后自动删除。</p>
          <div id="pendingDeleteList" class="host-manage-list"></div>
        </section>
        <div class="host-setup-actions" style="margin-top: 10px">
          <button id="hostManageAddBtn" class="btn btn-primary">添加宿主机</button>
          <button id="hostManageDebugBtn" class="btn btn-outline">打开调试入口</button>
        </div>
      </div>
    </div>

    <div id="hostEditModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3>修改宿主机信息</h3>
          <button id="hostEditClose" class="icon-btn" aria-label="关闭">×</button>
        </div>
        <section class="detail-card">
          <div class="field">
            <label for="hostEditNameInput">宿主机名称</label>
            <input id="hostEditNameInput" type="text" placeholder="例如 我的 MacBook Pro" />
          </div>
          <div class="field" style="margin-top: 8px">
            <label for="hostEditNoteInput">备注</label>
            <input id="hostEditNoteInput" type="text" placeholder="例如 工作机 / 家里主机" />
          </div>
          <div class="host-setup-actions" style="margin-top: 12px">
            <button id="hostEditSaveBtn" class="btn btn-primary">保存修改</button>
            <button id="hostEditCancelBtn" class="btn btn-outline">取消</button>
          </div>
        </section>
      </div>
    </div>

    <div id="hostNoticeModal" class="modal">
      <div class="modal-card">
        <div class="modal-top">
          <h3>提示</h3>
          <button id="hostNoticeClose" class="icon-btn" aria-label="关闭">×</button>
        </div>
        <section class="detail-card">
          <h4 id="hostNoticeTitle" class="detail-title" style="font-size: 16px">宿主机名称重复</h4>
          <p id="hostNoticeBody" class="section-sub" style="margin: 0">建议立即修改名称，避免后续识别困难。</p>
          <div class="host-setup-actions" style="margin-top: 12px">
            <button id="hostNoticePrimaryBtn" class="btn btn-primary">去修改名称</button>
            <button id="hostNoticeSecondaryBtn" class="btn btn-outline">稍后处理</button>
          </div>
        </section>
      </div>
    </div>

    <script>
      // 文件职责（脚本部分）：
      // 1. 维护多宿主机状态、连接生命周期与删除补偿队列。
      // 2. 提供配对流程（扫码/图库/粘贴/手动）与统一失败提示。
      // 3. 渲染 Banner 总览、按宿主机分组的工具列表、调试入口与工具详情。

      const STORAGE_KEY = "yc_mobile_tauri_hosts_v2";
      const LEGACY_STORAGE_KEY = "yc_mobile_tauri_debug";
      const DEFAULT_RELAY_WS_URL = "ws://127.0.0.1:18080/v1/ws";
      const RECONNECT_INTERVAL_MS = 2000;
      const MAX_RECONNECT_ATTEMPTS = 5;
      const DELETE_RETRY_INTERVAL_MS = 2000;

      const state = {
        // 宿主机配置与运行时。
        deviceId: "",
        hosts: [],
        selectedHostId: "",
        runtimes: {},
        pendingHostDeletes: [],

        // 全局 UI 状态。
        activeTab: "ops",
        bannerActiveIndex: 0,
        logs: [],
        eventIn: 0,
        eventOut: 0,
        message: "tool_ping",
        debugHostId: "",

        // 弹窗与临时操作状态。
        detailHostId: "",
        detailToolId: "",
        detailExpanded: false,
        addToolHostId: "",
        pairingBusy: false,
        pairFlowStep: "import",
        pairFailurePrimaryAction: "",
        pairTargetHostId: "",
        editingHostId: "",
        hostNoticeTargetId: "",

        // 扫码状态。
        scanDetector: null,
        scanStream: null,
        scanning: false,

        // 删除补偿执行状态。
        deleteCompensating: false,
      };

      function createRuntime() {
        return {
          socket: null,
          connectionEpoch: 0,
          connecting: false,
          connected: false,
          status: "DISCONNECTED",
          sidecarStatus: "UNKNOWN",
          lastHeartbeatAt: null,
          reconnectTimer: null,
          retryCount: 0,
          manualReconnectRequired: false,
          lastError: "",

          systemMetrics: {},
          sidecarMetrics: {},
          primaryToolMetrics: {},
          toolMetricsById: {},
          tools: [],
          candidateTools: [],
          connectingToolIds: {},
          toolConnectRetryCount: {},
          toolConnectTimers: {},

          accessToken: "",
          refreshToken: "",
          keyId: "",
          credentialId: "",
          devicePublicKey: "",
        };
      }

      const ui = {
        // 基础页面。
        opsView: document.getElementById("opsView"),
        debugView: document.getElementById("debugView"),
        tabOps: document.getElementById("tabOps"),
        tabDebug: document.getElementById("tabDebug"),

        // 顶部操作。
        connectBtnTop: document.getElementById("connectBtnTop"),
        disconnectBtnTop: document.getElementById("disconnectBtnTop"),
        replaceHostBtnTop: document.getElementById("replaceHostBtnTop"),

        // 配对与总览。
        hostSetupCard: document.getElementById("hostSetupCard"),
        hostOverviewWrap: document.getElementById("hostOverviewWrap"),
        importPairLinkBtn: document.getElementById("importPairLinkBtn"),
        openManualPairBtn: document.getElementById("openManualPairBtn"),
        openDebugFromSetupBtn: document.getElementById("openDebugFromSetupBtn"),
        hostBannerTrack: document.getElementById("hostBannerTrack"),
        hostBannerDots: document.getElementById("hostBannerDots"),
        toolsGroupedList: document.getElementById("toolsGroupedList"),

        // 调试页。
        debugStatus: document.getElementById("debugStatus"),
        debugEvents: document.getElementById("debugEvents"),
        debugHostSelect: document.getElementById("debugHostSelect"),
        debugIdentity: document.getElementById("debugIdentity"),
        connectBtnDebug: document.getElementById("connectBtnDebug"),
        disconnectBtnDebug: document.getElementById("disconnectBtnDebug"),
        rebindControllerBtn: document.getElementById("rebindControllerBtn"),
        messageInput: document.getElementById("messageInput"),
        sendBtn: document.getElementById("sendBtn"),
        logBox: document.getElementById("logBox"),

        // 工具详情。
        toolModal: document.getElementById("toolModal"),
        toolModalTitle: document.getElementById("toolModalTitle"),
        toolModalClose: document.getElementById("toolModalClose"),
        summaryRows: document.getElementById("summaryRows"),
        detailRows: document.getElementById("detailRows"),
        detailTip: document.getElementById("detailTip"),
        toggleDetailsBtn: document.getElementById("toggleDetailsBtn"),
        usagePanel: document.getElementById("usagePanel"),
        usageRows: document.getElementById("usageRows"),

        // 添加工具。
        addToolModal: document.getElementById("addToolModal"),
        addToolModalClose: document.getElementById("addToolModalClose"),
        candidateList: document.getElementById("candidateList"),
        goDebugFromAddTool: document.getElementById("goDebugFromAddTool"),

        // 配对流程。
        pairFlowModal: document.getElementById("pairFlowModal"),
        pairFlowTitle: document.getElementById("pairFlowTitle"),
        pairFlowClose: document.getElementById("pairFlowClose"),
        pairFlowStepImport: document.getElementById("pairFlowStepImport"),
        pairFlowStepPaste: document.getElementById("pairFlowStepPaste"),
        pairFlowStepScan: document.getElementById("pairFlowStepScan"),
        pairFlowStepManual: document.getElementById("pairFlowStepManual"),
        pairOpenScanBtn: document.getElementById("pairOpenScanBtn"),
        pairOpenPasteBtn: document.getElementById("pairOpenPasteBtn"),
        pairPasteSubmitBtn: document.getElementById("pairPasteSubmitBtn"),
        pairPasteBackBtn: document.getElementById("pairPasteBackBtn"),
        pairScanVideo: document.getElementById("pairScanVideo"),
        pairScanStatus: document.getElementById("pairScanStatus"),
        pairScanFileInput: document.getElementById("pairScanFileInput"),
        pairScanGalleryBtn: document.getElementById("pairScanGalleryBtn"),
        pairScanBackBtn: document.getElementById("pairScanBackBtn"),
        hostRelayInput: document.getElementById("hostRelayInput"),
        hostPairCodeInput: document.getElementById("hostPairCodeInput"),
        hostNameInput: document.getElementById("hostNameInput"),
        pairManualSubmitBtn: document.getElementById("pairManualSubmitBtn"),
        pairManualBackBtn: document.getElementById("pairManualBackBtn"),
        pairLinkInput: document.getElementById("pairLinkInput"),

        // 配对失败弹窗。
        pairFailureModal: document.getElementById("pairFailureModal"),
        pairFailureClose: document.getElementById("pairFailureClose"),
        pairFailureReason: document.getElementById("pairFailureReason"),
        pairFailureSuggestion: document.getElementById("pairFailureSuggestion"),
        pairFailurePrimaryBtn: document.getElementById("pairFailurePrimaryBtn"),
        pairFailureSecondaryBtn: document.getElementById("pairFailureSecondaryBtn"),

        // 宿主管理。
        hostManageModal: document.getElementById("hostManageModal"),
        hostManageClose: document.getElementById("hostManageClose"),
        hostManageList: document.getElementById("hostManageList"),
        pendingDeleteList: document.getElementById("pendingDeleteList"),
        hostManageAddBtn: document.getElementById("hostManageAddBtn"),
        hostManageDebugBtn: document.getElementById("hostManageDebugBtn"),

        // 宿主机编辑。
        hostEditModal: document.getElementById("hostEditModal"),
        hostEditClose: document.getElementById("hostEditClose"),
        hostEditNameInput: document.getElementById("hostEditNameInput"),
        hostEditNoteInput: document.getElementById("hostEditNoteInput"),
        hostEditSaveBtn: document.getElementById("hostEditSaveBtn"),
        hostEditCancelBtn: document.getElementById("hostEditCancelBtn"),

        // 通知弹窗（重名/删除补偿提示）。
        hostNoticeModal: document.getElementById("hostNoticeModal"),
        hostNoticeClose: document.getElementById("hostNoticeClose"),
        hostNoticeTitle: document.getElementById("hostNoticeTitle"),
        hostNoticeBody: document.getElementById("hostNoticeBody"),
        hostNoticePrimaryBtn: document.getElementById("hostNoticePrimaryBtn"),
        hostNoticeSecondaryBtn: document.getElementById("hostNoticeSecondaryBtn"),
      };

      function init() {
        restoreConfig();
        ensureIdentity();
        bindPairingLinkBridge();
        tryApplyLaunchPairingLink();

        ui.messageInput.value = state.message;

        ui.tabOps.addEventListener("click", () => switchTab("ops"));
        ui.tabDebug.addEventListener("click", () => switchTab("debug"));

        ui.connectBtnTop.addEventListener("click", connectAllHosts);
        ui.disconnectBtnTop.addEventListener("click", disconnectAllHosts);
        ui.replaceHostBtnTop.addEventListener("click", openHostManageModal);

        ui.importPairLinkBtn.addEventListener("click", () => openPairFlow("import", ""));
        ui.openManualPairBtn.addEventListener("click", () => openPairFlow("manual", ""));
        ui.openDebugFromSetupBtn.addEventListener("click", () => switchTab("debug"));

        ui.connectBtnDebug.addEventListener("click", () => connectHost(state.debugHostId, { manual: true, resetRetry: true }));
        ui.disconnectBtnDebug.addEventListener("click", () => disconnectHost(state.debugHostId, { triggerReconnect: true }));
        ui.rebindControllerBtn.addEventListener("click", () => requestControllerRebind(state.debugHostId));
        ui.debugHostSelect.addEventListener("change", () => {
          state.debugHostId = String(ui.debugHostSelect.value || "");
          render();
        });

        ui.messageInput.addEventListener("input", () => {
          state.message = ui.messageInput.value;
          persistConfig();
          render();
        });
        ui.sendBtn.addEventListener("click", sendTestEvent);

        ui.toolsGroupedList.addEventListener("click", onToolsGroupedClick);
        ui.hostBannerTrack.addEventListener("scroll", onHostBannerScroll);

        ui.toolModalClose.addEventListener("click", closeToolDetail);
        ui.toolModal.addEventListener("click", (event) => {
          if (event.target === ui.toolModal) {
            closeToolDetail();
          }
        });
        ui.toggleDetailsBtn.addEventListener("click", () => {
          state.detailExpanded = !state.detailExpanded;
          renderToolModal();
        });

        ui.addToolModalClose.addEventListener("click", closeAddToolModal);
        ui.addToolModal.addEventListener("click", (event) => {
          if (event.target === ui.addToolModal) {
            closeAddToolModal();
          }
        });
        ui.candidateList.addEventListener("click", onCandidateListClick);
        ui.goDebugFromAddTool.addEventListener("click", () => {
          closeAddToolModal();
          switchTab("debug");
        });

        ui.pairFlowClose.addEventListener("click", closePairFlow);
        ui.pairFlowModal.addEventListener("click", (event) => {
          if (event.target === ui.pairFlowModal) {
            closePairFlow();
          }
        });
        ui.pairOpenScanBtn.addEventListener("click", () => openPairFlow("scan"));
        ui.pairOpenPasteBtn.addEventListener("click", () => openPairFlow("paste"));
        ui.pairPasteBackBtn.addEventListener("click", () => openPairFlow("import"));
        ui.pairScanBackBtn.addEventListener("click", () => openPairFlow("import"));
        ui.pairManualBackBtn.addEventListener("click", closePairFlow);
        ui.pairPasteSubmitBtn.addEventListener("click", () => runPairingFromLink(ui.pairLinkInput.value, "paste"));
        ui.pairManualSubmitBtn.addEventListener("click", runPairingFromManual);
        ui.pairLinkInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            void runPairingFromLink(ui.pairLinkInput.value, "paste");
          }
        });
        ui.pairScanGalleryBtn.addEventListener("click", () => ui.pairScanFileInput.click());
        ui.pairScanFileInput.addEventListener("change", onPairScanFileSelected);

        ui.pairFailureClose.addEventListener("click", closePairFailureModal);
        ui.pairFailureSecondaryBtn.addEventListener("click", closePairFailureModal);
        ui.pairFailurePrimaryBtn.addEventListener("click", () => {
          const action = state.pairFailurePrimaryAction;
          closePairFailureModal();
          if (action === "scan") {
            openPairFlow("scan");
          } else if (action === "manual") {
            openPairFlow("manual");
          } else {
            openPairFlow("paste");
          }
        });

        ui.hostManageClose.addEventListener("click", closeHostManageModal);
        ui.hostManageModal.addEventListener("click", (event) => {
          if (event.target === ui.hostManageModal) {
            closeHostManageModal();
          }
        });
        ui.hostManageAddBtn.addEventListener("click", () => {
          closeHostManageModal();
          openPairFlow("import", "");
        });
        ui.hostManageDebugBtn.addEventListener("click", () => {
          closeHostManageModal();
          switchTab("debug");
        });
        ui.hostManageList.addEventListener("click", onHostManageListClick);
        ui.pendingDeleteList.addEventListener("click", onPendingDeleteListClick);

        ui.hostEditClose.addEventListener("click", closeHostEditModal);
        ui.hostEditCancelBtn.addEventListener("click", closeHostEditModal);
        ui.hostEditSaveBtn.addEventListener("click", saveHostEdit);
        ui.hostEditModal.addEventListener("click", (event) => {
          if (event.target === ui.hostEditModal) {
            closeHostEditModal();
          }
        });

        ui.hostNoticeClose.addEventListener("click", closeHostNoticeModal);
        ui.hostNoticeSecondaryBtn.addEventListener("click", closeHostNoticeModal);
        ui.hostNoticePrimaryBtn.addEventListener("click", () => {
          const hostId = state.hostNoticeTargetId;
          closeHostNoticeModal();
          if (hostId) {
            openHostEditModal(hostId);
          }
        });
        ui.hostNoticeModal.addEventListener("click", (event) => {
          if (event.target === ui.hostNoticeModal) {
            closeHostNoticeModal();
          }
        });

        document.addEventListener("keydown", (event) => {
          if (event.key !== "Escape") {
            return;
          }
          closePairFailureModal();
          closePairFlow();
          closeToolDetail();
          closeAddToolModal();
          closeHostManageModal();
          closeHostEditModal();
          closeHostNoticeModal();
        });

        // 删除补偿与心跳重试都依赖同一个周期轮询。
        setInterval(() => {
          void processPendingDeletes();
        }, DELETE_RETRY_INTERVAL_MS);

        if (visibleHosts().length > 0) {
          connectAllHosts();
        }

        render();
      }

      function switchTab(tab) {
        state.activeTab = tab;
        render();
      }

      function visibleHosts() {
        return [...state.hosts]
          .sort((a, b) => new Date(a.pairedAt).getTime() - new Date(b.pairedAt).getTime());
      }

      function hostById(hostId) {
        const id = String(hostId || "");
        if (!id) {
          return null;
        }
        return state.hosts.find((host) => host.hostId === id) || null;
      }

      function ensureRuntime(hostId) {
        const id = String(hostId || "");
        if (!id) {
          return null;
        }
        if (!state.runtimes[id]) {
          state.runtimes[id] = createRuntime();
        }
        return state.runtimes[id];
      }

      function disposeRuntime(hostId) {
        const runtime = state.runtimes[hostId];
        if (!runtime) {
          return;
        }
        runtime.connectionEpoch += 1;
        if (runtime.reconnectTimer) {
          clearTimeout(runtime.reconnectTimer);
          runtime.reconnectTimer = null;
        }
        if (runtime.socket) {
          runtime.socket.close();
          runtime.socket = null;
        }
        delete state.runtimes[hostId];
      }

      function recomputeSelections() {
        const hosts = visibleHosts();
        if (hosts.length === 0) {
          state.selectedHostId = "";
          state.debugHostId = "";
          state.bannerActiveIndex = 0;
          return;
        }

        const hasSelected = hosts.some((host) => host.hostId === state.selectedHostId);
        if (!hasSelected) {
          state.selectedHostId = hosts[0].hostId;
        }

        const hasDebug = hosts.some((host) => host.hostId === state.debugHostId);
        if (!hasDebug) {
          state.debugHostId = state.selectedHostId;
        }

        const maxIndex = Math.max(0, hosts.length - 1);
        state.bannerActiveIndex = Math.min(Math.max(0, state.bannerActiveIndex), maxIndex);
      }

      function persistConfig() {
        const payload = {
          schemaVersion: 2,
          deviceId: state.deviceId,
          selectedHostId: state.selectedHostId,
          hosts: state.hosts.map((host) => ({
            hostId: host.hostId,
            systemId: host.systemId,
            relayUrl: host.relayUrl,
            displayName: host.displayName,
            note: host.note || "",
            pairedAt: host.pairedAt,
            updatedAt: host.updatedAt,
            autoConnect: host.autoConnect !== false,
          })),
          pendingHostDeletes: state.pendingHostDeletes,
          message: state.message,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }

      function restoreConfig() {
        let parsed = null;
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) {
            parsed = JSON.parse(raw);
          }
        } catch (_) {
          parsed = null;
        }

        if (!parsed) {
          parsed = migrateLegacyConfig();
        }
        if (!parsed) {
          return;
        }

        state.deviceId = String(parsed.deviceId || "").trim();
        state.selectedHostId = String(parsed.selectedHostId || "").trim();
        state.message = String(parsed.message || state.message);

        const hosts = Array.isArray(parsed.hosts) ? parsed.hosts : [];
        state.hosts = hosts
          .map((item) => normalizeHostProfile(item))
          .filter((item) => item && item.hostId && item.systemId && item.relayUrl);

        const pending = Array.isArray(parsed.pendingHostDeletes) ? parsed.pendingHostDeletes : [];
        state.pendingHostDeletes = pending
          .map((item) => normalizePendingDelete(item))
          .filter((item) => item && item.hostId && item.systemId && item.relayUrl);

        recomputeSelections();
      }

      function migrateLegacyConfig() {
        try {
          const raw = localStorage.getItem(LEGACY_STORAGE_KEY);
          if (!raw) {
            return null;
          }
          const legacy = JSON.parse(raw);
          const relayUrl = String(legacy.relayUrl || "").trim();
          const systemId = String(legacy.systemId || "").trim();
          if (!relayUrl || !systemId) {
            return null;
          }

          const now = new Date().toISOString();
          const hostId = `host_${createEventId().slice(4)}`;
          return {
            schemaVersion: 2,
            deviceId: String(legacy.deviceId || "").trim(),
            selectedHostId: hostId,
            hosts: [
              {
                hostId,
                systemId,
                relayUrl,
                displayName: String(legacy.hostName || "").trim() || systemId,
                note: "",
                pairedAt: now,
                updatedAt: now,
                autoConnect: true,
              },
            ],
            pendingHostDeletes: [],
            message: String(legacy.message || "tool_ping"),
          };
        } catch (_) {
          return null;
        }
      }

      function normalizeHostProfile(item) {
        const now = new Date().toISOString();
        const relayUrl = String(item.relayUrl || "").trim();
        const systemId = String(item.systemId || "").trim();
        if (!relayUrl || !systemId) {
          return null;
        }
        return {
          hostId: String(item.hostId || `host_${createEventId().slice(4)}`),
          systemId,
          relayUrl,
          displayName: String(item.displayName || item.hostName || systemId).trim() || systemId,
          note: String(item.note || "").trim(),
          pairedAt: String(item.pairedAt || now),
          updatedAt: String(item.updatedAt || now),
          autoConnect: item.autoConnect !== false,
        };
      }

      function normalizePendingDelete(item) {
        const now = Date.now();
        const relayUrl = String(item.relayUrl || "").trim();
        const systemId = String(item.systemId || "").trim();
        const hostId = String(item.hostId || "").trim();
        if (!relayUrl || !systemId || !hostId) {
          return null;
        }
        return {
          hostId,
          systemId,
          relayUrl,
          displayName: String(item.displayName || systemId),
          deviceId: String(item.deviceId || state.deviceId || "").trim(),
          enqueuedAt: Number(item.enqueuedAt || now),
          retryCount: Number(item.retryCount || 0),
          nextRetryAt: Number(item.nextRetryAt || now),
          lastError: String(item.lastError || ""),
          expectedCredentialId: String(item.expectedCredentialId || "").trim(),
          expectedKeyId: String(item.expectedKeyId || "").trim(),
        };
      }

      function ensureIdentity() {
        if (!state.deviceId) {
          state.deviceId = createDeviceId();
          persistConfig();
        }
      }

      function createDeviceId() {
        if (window.crypto && typeof window.crypto.randomUUID === "function") {
          return `ios_${window.crypto.randomUUID()}`;
        }
        const rand = Math.random().toString(36).slice(2, 10);
        return `ios_${Date.now()}_${rand}`;
      }

      function createEventId() {
        if (window.crypto && typeof window.crypto.randomUUID === "function") {
          return `evt_${window.crypto.randomUUID()}`;
        }
        const rand = Math.random().toString(36).slice(2, 10);
        return `evt_${Date.now()}_${rand}`;
      }

      async function tauriInvoke(command, payload = {}) {
        const invokeV2 = window.__TAURI__ && window.__TAURI__.core && window.__TAURI__.core.invoke;
        if (typeof invokeV2 === "function") {
          return invokeV2(command, payload);
        }
        const invokeLegacy = window.__TAURI_INTERNALS__ && window.__TAURI_INTERNALS__.invoke;
        if (typeof invokeLegacy === "function") {
          return invokeLegacy(command, payload);
        }
        throw new Error("Tauri invoke 不可用");
      }

      async function loadHostSession(hostId) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime) {
          return null;
        }
        try {
          const session = await tauriInvoke("auth_load_session", {
            systemId: host.systemId,
            deviceId: state.deviceId,
          });
          if (!session) {
            return null;
          }
          runtime.accessToken = String(session.accessToken || "");
          runtime.refreshToken = String(session.refreshToken || "");
          runtime.keyId = String(session.keyId || "");
          runtime.credentialId = String(session.credentialId || "");
          return session;
        } catch (error) {
          addLog(`load secure session failed (${host.displayName}): ${error}`);
          return null;
        }
      }

      async function storeHostSession(hostId) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime) {
          return;
        }
        await tauriInvoke("auth_store_session", {
          session: {
            systemId: host.systemId,
            deviceId: state.deviceId,
            accessToken: runtime.accessToken,
            refreshToken: runtime.refreshToken,
            keyId: runtime.keyId,
            credentialId: runtime.credentialId,
          },
        });
      }

      async function clearHostSession(systemId) {
        await tauriInvoke("auth_clear_session", {
          systemId,
          deviceId: state.deviceId,
        });
      }

      function parseRelayWsUrl(relayWsUrl) {
        const raw = String(relayWsUrl || "").trim();
        const ws = new URL(raw);
        if (ws.protocol !== "ws:" && ws.protocol !== "wss:") {
          const err = new Error(`relay url protocol unsupported: ${ws.protocol}`);
          err.code = "RELAY_URL_INVALID";
          throw err;
        }
        return ws;
      }

      function buildHostWithPort(hostname, port) {
        const withBracket = hostname.includes(":") && !hostname.startsWith("[") ? `[${hostname}]` : hostname;
        return port ? `${withBracket}:${port}` : withBracket;
      }

      function relayApiBases(relayWsUrl) {
        const ws = parseRelayWsUrl(relayWsUrl);
        const protocol = ws.protocol === "wss:" ? "https:" : "http:";
        const pathname = ws.pathname.endsWith("/ws") ? ws.pathname.slice(0, -3) : ws.pathname;
        const normalizedPath = pathname.replace(/\/+$/, "");

        const hosts = [ws.host];
        const hostName = ws.hostname.toLowerCase();
        if (hostName === "127.0.0.1") {
          hosts.push(buildHostWithPort("localhost", ws.port));
        } else if (hostName === "localhost") {
          hosts.push(buildHostWithPort("127.0.0.1", ws.port));
        }

        return [...new Set(hosts)].map((host) => `${protocol}//${host}${normalizedPath}`);
      }

      function isRelayNetworkError(error) {
        const text = String(error || "");
        return (
          error instanceof TypeError ||
          /failed to fetch|networkerror|load failed|operation not permitted|network request failed/i.test(text)
        );
      }

      async function relayRequestJson(relayWsUrl, path, init) {
        const bases = relayApiBases(relayWsUrl);
        let lastNetworkError = null;

        for (const base of bases) {
          try {
            const resp = await fetch(`${base}${path}`, init);
            const text = await resp.text();
            let body = {};
            if (text) {
              try {
                body = JSON.parse(text);
              } catch (parseError) {
                const err = new Error(`relay response not json: ${parseError}`);
                err.code = "RELAY_RESPONSE_INVALID";
                throw err;
              }
            }
            return { resp, body, apiBase: base };
          } catch (error) {
            if (!isRelayNetworkError(error)) {
              throw error;
            }
            lastNetworkError = error;
          }
        }

        if (lastNetworkError) {
          const err = new Error(`relay unreachable: ${lastNetworkError}`);
          err.code = "RELAY_UNREACHABLE";
          throw err;
        }
        const err = new Error("relay request failed");
        err.code = "RELAY_UNREACHABLE";
        throw err;
      }

      function openPairFlow(step = "import", targetHostId) {
        state.pairFlowStep = step;
        if (typeof targetHostId === "string") {
          state.pairTargetHostId = String(targetHostId || "");
        }

        const targetHost = hostById(state.pairTargetHostId);
        ui.hostRelayInput.value = targetHost ? targetHost.relayUrl : DEFAULT_RELAY_WS_URL;
        ui.hostNameInput.value = targetHost ? targetHost.displayName : "";
        ui.hostPairCodeInput.value = "";

        ui.pairFlowModal.classList.add("show");
        renderPairFlow();
      }

      function closePairFlow() {
        ui.pairFlowModal.classList.remove("show");
        stopPairScan();
        state.pairTargetHostId = "";
      }

      function renderPairFlow() {
        const step = state.pairFlowStep;
        ui.pairFlowStepImport.style.display = step === "import" ? "block" : "none";
        ui.pairFlowStepPaste.style.display = step === "paste" ? "block" : "none";
        ui.pairFlowStepScan.style.display = step === "scan" ? "block" : "none";
        ui.pairFlowStepManual.style.display = step === "manual" ? "block" : "none";

        const isRePair = Boolean(state.pairTargetHostId);
        if (isRePair) {
          ui.pairFlowTitle.textContent = step === "manual" ? "重新配对（手动）" : "重新配对";
        } else {
          ui.pairFlowTitle.textContent = step === "manual" ? "手动填写配对码" : "导入配对链接";
        }

        if (step === "scan") {
          void startPairScan();
        } else {
          stopPairScan();
        }
      }

      function setPairScanStatus(text = "", level = "normal") {
        ui.pairScanStatus.textContent = String(text || "");
        ui.pairScanStatus.style.color = level === "warn" ? "var(--warn)" : "var(--text-sub)";
      }

      function closePairFailureModal() {
        ui.pairFailureModal.classList.remove("show");
      }

      function showPairFailure(code, message, suggestion, primaryAction = "paste") {
        const mapped = mapPairFailure(code, message, suggestion, primaryAction);
        state.pairFailurePrimaryAction = mapped.primaryAction;
        ui.pairFailureReason.textContent = mapped.reason;
        ui.pairFailureSuggestion.textContent = mapped.suggestion;
        ui.pairFailurePrimaryBtn.textContent = mapped.primaryLabel;
        ui.pairFailureModal.classList.add("show");
      }

      function mapPairFailure(code, message, suggestion, primaryAction) {
        const normalizedCode = String(code || "").trim();
        const fallbackMessage = String(message || "").trim();
        if (normalizedCode === "INVALID_LINK") {
          return {
            reason: "配对链接无效",
            suggestion: "请重新扫码或检查粘贴内容是否完整。",
            primaryLabel: "重新粘贴",
            primaryAction: "paste",
          };
        }
        if (normalizedCode === "PAIR_TICKET_EXPIRED" || normalizedCode === "PAIR_TICKET_REPLAYED") {
          return {
            reason: normalizedCode === "PAIR_TICKET_EXPIRED" ? "配对信息已过期" : "配对二维码已使用",
            suggestion: "请重新扫码获取最新二维码。",
            primaryLabel: "重新扫码",
            primaryAction: "scan",
          };
        }
        if (normalizedCode === "PAIR_TICKET_INVALID") {
          return {
            reason: "配对信息无效",
            suggestion: "请重新扫码获取最新二维码，或改用手动配对。",
            primaryLabel: "重新扫码",
            primaryAction: "scan",
          };
        }
        if (normalizedCode === "SYSTEM_NOT_REGISTERED") {
          return {
            reason: "宿主机未在线",
            suggestion: "请先在宿主机启动 sidecar，再进行配对。",
            primaryLabel: "去手动输入",
            primaryAction: "manual",
          };
        }
        if (normalizedCode === "RELAY_URL_INVALID") {
          return {
            reason: "Relay 地址格式无效",
            suggestion: "请使用 ws:// 或 wss:// 开头的 Relay 地址。",
            primaryLabel: "去手动输入",
            primaryAction: "manual",
          };
        }
        if (normalizedCode === "RELAY_UNREACHABLE") {
          const action = primaryAction === "manual" ? "manual" : primaryAction === "scan" ? "scan" : "paste";
          return {
            reason: "无法连接 Relay",
            suggestion:
              suggestion ||
              "请检查 Relay 地址、宿主机网络，并确认 relay 已启动（make run-relay）。本机调试可尝试 127.0.0.1 与 localhost 两种地址。",
            primaryLabel: action === "manual" ? "去手动输入" : action === "scan" ? "重新扫码" : "重新粘贴",
            primaryAction: action,
          };
        }
        if (normalizedCode === "QR_SCANNER_UNAVAILABLE") {
          return {
            reason: "当前设备不支持实时扫码",
            suggestion: "请改用“从图库导入二维码”或“粘贴配对链接”。",
            primaryLabel: "重新粘贴",
            primaryAction: "paste",
          };
        }
        if (normalizedCode === "CAMERA_UNAVAILABLE") {
          return {
            reason: "无法打开相机",
            suggestion: "请检查相机权限，或改用“从图库导入二维码/粘贴配对链接”。",
            primaryLabel: "重新粘贴",
            primaryAction: "paste",
          };
        }
        if (normalizedCode === "PAIR_TOKEN_MISMATCH") {
          return {
            reason: "配对信息无效",
            suggestion: "请重新生成配对信息后再试。",
            primaryLabel: "重新扫码",
            primaryAction: "scan",
          };
        }
        if (normalizedCode === "ACCESS_TOKEN_EXPIRED" || normalizedCode === "ACCESS_TOKEN_INVALID") {
          return {
            reason: "设备凭证失效",
            suggestion: "请重新扫码配对，更新设备凭证。",
            primaryLabel: "重新扫码",
            primaryAction: "scan",
          };
        }
        return {
          reason: fallbackMessage || "配对失败",
          suggestion: suggestion || "请重试；若仍失败可切换到手动填写配对码。",
          primaryLabel: primaryAction === "manual" ? "去手动输入" : primaryAction === "scan" ? "重新扫码" : "重试",
          primaryAction: primaryAction || "paste",
        };
      }

      async function runPairingFromLink(rawValue, source = "paste") {
        const parsed = parsePairingLink(rawValue);
        if (!parsed) {
          showPairFailure("INVALID_LINK", "配对链接格式无效", "请检查链接是否完整。", "paste");
          return;
        }
        await runPairing(parsed, source);
      }

      async function runPairingFromManual() {
        const relayUrl = String(ui.hostRelayInput.value || "").trim();
        const pairCode = String(ui.hostPairCodeInput.value || "").trim();
        const hostName = String(ui.hostNameInput.value || "").trim();
        const parsedCode = parsePairCode(pairCode);
        if (!relayUrl || !parsedCode) {
          showPairFailure("PAIR_TOKEN_MISMATCH", "手动配对信息不完整", "请确认 Relay 地址和配对码格式。", "manual");
          return;
        }
        try {
          parseRelayWsUrl(relayUrl);
        } catch (_) {
          showPairFailure("RELAY_URL_INVALID", "Relay 地址格式无效", "请填写 ws:// 或 wss:// 开头的地址。", "manual");
          return;
        }

        await runPairing(
          {
            relayUrl,
            pairCode,
            systemId: parsedCode.systemId,
            pairToken: parsedCode.pairToken,
            pairTicket: "",
            hostName,
          },
          "manual",
        );
      }

      async function runPairing(parsed, source) {
        if (state.pairingBusy) {
          return;
        }

        state.pairingBusy = true;
        try {
          const relayUrl = String(parsed.relayUrl || "").trim();
          const systemId = String(parsed.systemId || "").trim();
          const pairToken = String(parsed.pairToken || "").trim();
          const pairTicket = String(parsed.pairTicket || "").trim();
          // 若已提供短时票据，则请求中不再携带 pairToken，避免形成票据回退绕过链路。
          const pairTokenForRequest = pairTicket ? "" : pairToken;
          if (!relayUrl || !systemId || (!pairToken && !pairTicket)) {
            showPairFailure("PAIR_TOKEN_MISMATCH", "配对信息不完整", "请重新导入配对信息后重试。", source);
            return;
          }

          const preflightReq = {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              systemId,
              deviceId: state.deviceId,
              pairToken: pairTokenForRequest || undefined,
              pairTicket: pairTicket || undefined,
            }),
          };
          const { resp: preflightResp, body: preflightBody } = await relayRequestJson(relayUrl, "/pair/preflight", preflightReq);
          if (!preflightResp.ok || !preflightBody.ok) {
            const failureAction = source === "manual" ? "manual" : source === "scan" || source === "gallery" ? "scan" : "paste";
            showPairFailure(preflightBody.code, preflightBody.message, preflightBody.suggestion, failureAction);
            return;
          }

          const binding = await tauriInvoke("auth_get_device_binding", {
            deviceId: state.deviceId,
          });
          const keyId = String(binding.keyId || "");
          const devicePubKey = String(binding.publicKey || "");

          const proofPayload = `pair-exchange\n${systemId}\n${state.deviceId}\n${keyId}`;
          const proofSigned = await tauriInvoke("auth_sign_payload", {
            deviceId: state.deviceId,
            payload: proofPayload,
          });

          const exchangeReq = {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              systemId,
              deviceId: state.deviceId,
              deviceName: normalizedDeviceName(),
              pairToken: pairTokenForRequest || undefined,
              pairTicket: pairTicket || undefined,
              keyId,
              devicePubKey,
              proof: String(proofSigned.signature || ""),
            }),
          };
          const { resp: exchangeResp, body: exchangeBody } = await relayRequestJson(relayUrl, "/pair/exchange", exchangeReq);
          if (!exchangeResp.ok || !exchangeBody.ok) {
            const failureAction = source === "manual" ? "manual" : source === "scan" || source === "gallery" ? "scan" : "paste";
            showPairFailure(exchangeBody.code, exchangeBody.message, exchangeBody.suggestion, failureAction);
            return;
          }

          const exchangeData = asMap(exchangeBody.data);
          const targetHost = hostById(state.pairTargetHostId);
          const existingBySystem = state.hosts.find((host) => host.systemId === systemId && host.relayUrl === relayUrl);
          const host = targetHost || existingBySystem;
          const nowIso = new Date().toISOString();

          let hostId = "";
          if (host) {
            hostId = host.hostId;
            host.systemId = systemId;
            host.relayUrl = relayUrl;
            host.displayName = String(parsed.hostName || host.displayName || systemId).trim() || systemId;
            host.updatedAt = nowIso;
          } else {
            hostId = `host_${createEventId().slice(4)}`;
            state.hosts.push({
              hostId,
              systemId,
              relayUrl,
              displayName: String(parsed.hostName || systemId).trim() || systemId,
              note: "",
              pairedAt: nowIso,
              updatedAt: nowIso,
              autoConnect: true,
            });
          }

          recomputeSelections();
          state.selectedHostId = hostId;
          state.debugHostId = hostId;

          const runtime = ensureRuntime(hostId);
          runtime.accessToken = String(exchangeData.accessToken || "");
          runtime.refreshToken = String(exchangeData.refreshToken || "");
          runtime.keyId = String(exchangeData.keyId || keyId);
          runtime.credentialId = String(exchangeData.credentialId || "");
          runtime.devicePublicKey = devicePubKey;
          runtime.manualReconnectRequired = false;
          runtime.retryCount = 0;
          runtime.lastError = "";

          await storeHostSession(hostId);
          // 同一宿主机重新配对后，移除历史删除补偿任务，避免误吊销新会话。
          state.pendingHostDeletes = state.pendingHostDeletes.filter(
            (item) => !(item.systemId === systemId && item.relayUrl === relayUrl && item.deviceId === state.deviceId),
          );
          persistConfig();

          closePairFlow();
          closeHostManageModal();

          await connectHost(hostId, { manual: true, resetRetry: true });
          notifyIfDuplicateDisplayName(hostId);
          render();
        } catch (error) {
          const code = String(error && error.code ? error.code : "").trim();
          const failureCode = code || "RELAY_UNREACHABLE";
          showPairFailure(failureCode, `配对请求失败：${error}`, "请检查网络与 Relay 地址。", source);
        } finally {
          state.pairingBusy = false;
        }
      }

      function normalizedDeviceName() {
        return "ios_mobile";
      }

      function parsePairCode(rawValue) {
        const raw = String(rawValue || "").trim();
        if (!raw) {
          return null;
        }

        const cleaned = raw.replace(/\s+/g, "");
        const splitAt = cleaned.indexOf(".");
        if (splitAt <= 0 || splitAt >= cleaned.length - 1) {
          return null;
        }

        const systemId = cleaned.slice(0, splitAt);
        const pairToken = cleaned.slice(splitAt + 1);
        if (!systemId || !pairToken) {
          return null;
        }
        return { systemId, pairToken };
      }

      function parsePairingLink(rawValue) {
        const raw = String(rawValue || "").trim();
        if (!raw) {
          return null;
        }

        const matched = raw.match(/yc:\/\/pair\?[^ "'<>]+/i);
        const linkText = matched ? matched[0] : raw;
        let parsedUrl = null;
        try {
          parsedUrl = new URL(linkText);
        } catch (_) {
          return null;
        }

        if (parsedUrl.protocol !== "yc:" || parsedUrl.hostname !== "pair") {
          return null;
        }

        const relayUrl = String(parsedUrl.searchParams.get("relay") || "").trim();
        const pairCode = String(parsedUrl.searchParams.get("code") || "").trim();
        const systemIdFromSid = String(parsedUrl.searchParams.get("sid") || "").trim();
        const pairTicket = String(parsedUrl.searchParams.get("ticket") || "").trim();
        const hostName = String(parsedUrl.searchParams.get("name") || "").trim();
        if (!relayUrl) {
          return null;
        }
        try {
          parseRelayWsUrl(relayUrl);
        } catch (_) {
          return null;
        }

        if (pairCode) {
          const parsedCode = parsePairCode(pairCode);
          if (!parsedCode) {
            return null;
          }
          return {
            relayUrl,
            pairCode,
            systemId: parsedCode.systemId,
            pairToken: parsedCode.pairToken,
            pairTicket,
            hostName,
          };
        }

        if (!systemIdFromSid || !pairTicket) {
          return null;
        }

        return {
          relayUrl,
          pairCode: "",
          systemId: systemIdFromSid,
          pairToken: "",
          pairTicket,
          hostName,
        };
      }

      function bindPairingLinkBridge() {
        window.__YC_HANDLE_PAIR_LINK__ = (rawUrl) => {
          openPairFlow("import", "");
          void runPairingFromLink(rawUrl, "deep-link");
        };
      }

      function tryApplyLaunchPairingLink() {
        try {
          const launchUrl = new URL(window.location.href);
          if (launchUrl.protocol === "yc:" && launchUrl.hostname === "pair") {
            openPairFlow("import", "");
            void runPairingFromLink(launchUrl.toString(), "launch-url");
            return;
          }

          const relay = String(launchUrl.searchParams.get("relay") || "").trim();
          const code = String(launchUrl.searchParams.get("code") || "").trim();
          const sid = String(launchUrl.searchParams.get("sid") || "").trim();
          const ticket = String(launchUrl.searchParams.get("ticket") || "").trim();
          const name = String(launchUrl.searchParams.get("name") || "").trim();
          if (!relay || (!code && !(sid && ticket))) {
            return;
          }

          let syntheticLink = `yc://pair?relay=${encodeURIComponent(relay)}`;
          if (code) {
            syntheticLink += `&code=${encodeURIComponent(code)}`;
          } else {
            syntheticLink += `&sid=${encodeURIComponent(sid)}&ticket=${encodeURIComponent(ticket)}`;
          }
          if (name) {
            syntheticLink += `&name=${encodeURIComponent(name)}`;
          }
          openPairFlow("import", "");
          void runPairingFromLink(syntheticLink, "launch-url");
        } catch (_) {
          // ignore malformed launch url
        }
      }

      async function startPairScan() {
        if (state.scanning) {
          return;
        }
        if (typeof window.BarcodeDetector !== "function") {
          setPairScanStatus("当前环境不支持实时扫码，可改用“从图库导入二维码”或“粘贴配对链接”。", "warn");
          return;
        }

        try {
          state.scanning = true;
          setPairScanStatus("请将二维码放入取景框，识别后会自动配对。");
          state.scanDetector = state.scanDetector || new window.BarcodeDetector({ formats: ["qr_code"] });
          state.scanStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false,
          });
          ui.pairScanVideo.srcObject = state.scanStream;
          await ui.pairScanVideo.play();
          void scanLoop();
        } catch (error) {
          stopPairScan();
          setPairScanStatus("无法打开相机，请检查权限后重试。", "warn");
        }
      }

      function stopPairScan() {
        state.scanning = false;
        if (state.scanStream) {
          const tracks = state.scanStream.getTracks();
          for (const track of tracks) {
            track.stop();
          }
          state.scanStream = null;
        }
        if (ui.pairScanVideo) {
          ui.pairScanVideo.srcObject = null;
        }
      }

      async function scanLoop() {
        while (state.scanning) {
          try {
            if (!state.scanDetector || !ui.pairScanVideo || ui.pairScanVideo.readyState < 2) {
              await sleep(120);
              continue;
            }
            const found = await state.scanDetector.detect(ui.pairScanVideo);
            if (Array.isArray(found) && found.length > 0) {
              const raw = String(found[0].rawValue || "").trim();
              if (raw) {
                await runPairingFromLink(raw, "scan");
                stopPairScan();
                break;
              }
            }
          } catch (_) {
            // 扫码帧允许偶发失败，不中断扫描。
          }
          await sleep(120);
        }
      }

      async function onPairScanFileSelected(event) {
        const file = event.target && event.target.files && event.target.files[0];
        event.target.value = "";
        if (!file) {
          return;
        }
        if (typeof window.BarcodeDetector !== "function") {
          showPairFailure("QR_SCANNER_UNAVAILABLE", "当前环境不支持二维码识别", "请改用粘贴链接方式。", "paste");
          return;
        }
        try {
          const bitmap = await createImageBitmap(file);
          const detector = state.scanDetector || new window.BarcodeDetector({ formats: ["qr_code"] });
          const detected = await detector.detect(bitmap);
          const first = Array.isArray(detected) && detected.length > 0 ? detected[0] : null;
          const rawValue = first && typeof first.rawValue === "string" ? first.rawValue : "";
          if (!rawValue) {
            showPairFailure("INVALID_LINK", "未识别到有效二维码", "请更换清晰图片后重试。", "scan");
            return;
          }
          await runPairingFromLink(rawValue, "gallery");
        } catch (error) {
          showPairFailure("INVALID_LINK", `图片识别失败：${error}`, "请改用扫码或粘贴链接。", "paste");
        }
      }

      async function connectAllHosts() {
        const hosts = visibleHosts();
        await Promise.allSettled(
          hosts.map((host) => connectHost(host.hostId, { manual: true, resetRetry: true })),
        );
      }

      async function disconnectAllHosts() {
        const hosts = visibleHosts();
        await Promise.allSettled(
          hosts.map((host) => disconnectHost(host.hostId, { triggerReconnect: true })),
        );
      }

      async function reconnectHost(hostId) {
        await disconnectHost(hostId, { triggerReconnect: false });
        await connectHost(hostId, { manual: true, resetRetry: true });
      }

      async function connectHost(hostId, options = {}) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime) {
          return;
        }

        const manual = asBool(options.manual);
        const resetRetry = asBool(options.resetRetry);
        if (resetRetry) {
          runtime.retryCount = 0;
          runtime.manualReconnectRequired = false;
          runtime.lastError = "";
          clearReconnectTimer(runtime);
        }

        if (runtime.connecting || runtime.connected) {
          return;
        }

        runtime.connecting = true;
        runtime.status = "CONNECTING";
        render();

        try {
          await loadHostSession(hostId);
          if (!runtime.accessToken || !runtime.refreshToken || !runtime.keyId) {
            runtime.connecting = false;
            runtime.connected = false;
            runtime.status = "AUTH_EXPIRED";
            runtime.manualReconnectRequired = true;
            runtime.lastError = "缺少设备凭证，请重新配对";
            addLog(`connect skipped (${host.displayName}): 缺少可用凭证，请先完成配对`);
            render();
            return;
          }

          await refreshAccessTokenIfPossible(hostId);

          const connectionEpoch = runtime.connectionEpoch + 1;
          runtime.connectionEpoch = connectionEpoch;

          const url = new URL(host.relayUrl);
          url.searchParams.set("clientType", "app");
          url.searchParams.set("systemId", host.systemId);
          url.searchParams.set("deviceId", state.deviceId);

          const ts = String(Math.floor(Date.now() / 1000));
          const nonce = createEventId();
          const payload = `ws\n${host.systemId}\n${state.deviceId}\n${runtime.keyId}\n${ts}\n${nonce}`;
          const signed = await tauriInvoke("auth_sign_payload", {
            deviceId: state.deviceId,
            payload,
          });
          url.searchParams.set("accessToken", runtime.accessToken);
          url.searchParams.set("keyId", String(signed.keyId || runtime.keyId));
          url.searchParams.set("ts", ts);
          url.searchParams.set("nonce", nonce);
          url.searchParams.set("sig", String(signed.signature || ""));

          const socket = new WebSocket(url.toString());
          runtime.socket = socket;

          socket.addEventListener("open", () => {
            const current = ensureRuntime(hostId);
            if (!current || current.connectionEpoch !== connectionEpoch || current.socket !== socket) {
              return;
            }
            current.connected = true;
            current.connecting = false;
            current.status = "CONNECTED";
            current.sidecarStatus = "ONLINE";
            current.retryCount = 0;
            current.manualReconnectRequired = false;
            current.lastError = "";
            clearReconnectTimer(current);
            addLog(`connected host: ${host.displayName}`);
            requestToolsRefresh(hostId);
            render();
          });

          socket.addEventListener("message", (event) => {
            const current = ensureRuntime(hostId);
            if (!current || current.connectionEpoch !== connectionEpoch || current.socket !== socket) {
              return;
            }
            const text = String(event.data || "");
            state.eventIn += 1;
            addLog(`IN[${host.displayName}] ${text}`);
            ingestEvent(hostId, text);
            render();
          });

          socket.addEventListener("close", () => {
            const current = ensureRuntime(hostId);
            if (!current || current.connectionEpoch !== connectionEpoch || current.socket !== socket) {
              return;
            }
            current.connected = false;
            current.connecting = false;
            current.socket = null;
            current.status = "DISCONNECTED";
            addLog(`socket closed: ${host.displayName}`);
            scheduleReconnect(hostId, `socket closed (${host.displayName})`, manual);
            render();
          });

          socket.addEventListener("error", (error) => {
            const current = ensureRuntime(hostId);
            if (!current || current.connectionEpoch !== connectionEpoch || current.socket !== socket) {
              return;
            }
            current.connected = false;
            current.connecting = false;
            current.status = "RELAY_UNREACHABLE";
            current.lastError = String(error && error.message ? error.message : "socket error");
            addLog(`socket error (${host.displayName}): ${current.lastError}`);
            render();
          });
        } catch (error) {
          runtime.connected = false;
          runtime.connecting = false;
          runtime.socket = null;
          runtime.status = "RELAY_UNREACHABLE";
          runtime.lastError = String(error || "connect failed");
          addLog(`connect failed (${host.displayName}): ${error}`);
          scheduleReconnect(hostId, String(error || "connect failed"), manual);
          render();
        }
      }

      async function disconnectHost(hostId, options = {}) {
        const runtime = ensureRuntime(hostId);
        if (!runtime) {
          return;
        }

        const triggerReconnect = options.triggerReconnect !== false;
        runtime.connectionEpoch += 1;
        clearReconnectTimer(runtime);

        const socket = runtime.socket;
        runtime.socket = null;
        if (socket) {
          socket.close();
        }
        runtime.connected = false;
        runtime.connecting = false;
        runtime.status = "DISCONNECTED";
        runtime.sidecarStatus = "UNKNOWN";
        runtime.lastHeartbeatAt = null;
        runtime.candidateTools = [];
        runtime.connectingToolIds = {};
        runtime.toolConnectRetryCount = {};
        Object.keys(runtime.toolConnectTimers || {}).forEach((toolId) => clearToolConnectTimer(runtime, toolId));

        const host = hostById(hostId);
        addLog(`disconnected host: ${host ? host.displayName : hostId}`);

        if (triggerReconnect) {
          scheduleReconnect(hostId, "manual disconnect", true);
        }
        render();
      }

      function clearReconnectTimer(runtime) {
        if (runtime && runtime.reconnectTimer) {
          clearTimeout(runtime.reconnectTimer);
          runtime.reconnectTimer = null;
        }
      }

      function clearToolConnectTimer(runtime, toolId) {
        if (!runtime || !toolId) {
          return;
        }
        const timer = runtime.toolConnectTimers && runtime.toolConnectTimers[toolId];
        if (!timer) {
          return;
        }
        clearTimeout(timer);
        delete runtime.toolConnectTimers[toolId];
      }

      function scheduleReconnect(hostId, reason, manualTriggered) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime) {
          return;
        }
        if (runtime.manualReconnectRequired) {
          return;
        }
        if (runtime.reconnectTimer) {
          return;
        }
        if (host.autoConnect === false) {
          return;
        }

        if (runtime.retryCount >= MAX_RECONNECT_ATTEMPTS) {
          runtime.manualReconnectRequired = true;
          runtime.status = "DISCONNECTED";
          runtime.lastError = `重连失败已达 ${MAX_RECONNECT_ATTEMPTS} 次`;
          addLog(`reconnect paused (${host.displayName}): 超过 ${MAX_RECONNECT_ATTEMPTS} 次失败，请手动重连`);
          return;
        }

        runtime.retryCount += 1;
        runtime.reconnectTimer = setTimeout(() => {
          runtime.reconnectTimer = null;
          void connectHost(hostId, { manual: manualTriggered, resetRetry: false });
        }, RECONNECT_INTERVAL_MS);

        addLog(`reconnect scheduled (${host.displayName}) #${runtime.retryCount}: ${reason}`);
      }

      async function refreshAccessTokenIfPossible(hostId) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime) {
          return false;
        }
        if (!runtime.refreshToken || !runtime.keyId || !host.systemId || !state.deviceId) {
          return false;
        }

        try {
          const ts = String(Math.floor(Date.now() / 1000));
          const nonce = createEventId();
          const payload = `auth-refresh\n${host.systemId}\n${state.deviceId}\n${runtime.keyId}\n${ts}\n${nonce}`;
          const signed = await tauriInvoke("auth_sign_payload", {
            deviceId: state.deviceId,
            payload,
          });

          const { resp, body } = await relayRequestJson(host.relayUrl, "/auth/refresh", {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({
              systemId: host.systemId,
              deviceId: state.deviceId,
              refreshToken: runtime.refreshToken,
              keyId: String(signed.keyId || runtime.keyId),
              ts,
              nonce,
              sig: String(signed.signature || ""),
            }),
          });

          if (!resp.ok || !body.ok) {
            addLog(`refresh skipped (${host.displayName}): ${body.code || resp.status} ${body.message || ""}`);
            return false;
          }

          const data = asMap(body.data);
          runtime.accessToken = String(data.accessToken || runtime.accessToken);
          runtime.refreshToken = String(data.refreshToken || runtime.refreshToken);
          runtime.keyId = String(data.keyId || runtime.keyId);
          runtime.credentialId = String(data.credentialId || runtime.credentialId);
          await storeHostSession(hostId);
          return true;
        } catch (error) {
          addLog(`refresh failed (${host.displayName}): ${error}`);
          return false;
        }
      }

      function sendSocketEvent(hostId, type, payload) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        if (!host || !runtime || !runtime.socket || !runtime.connected) {
          addLog(`send skipped: host not connected (${host ? host.displayName : hostId})`);
          return false;
        }

        const event = {
          v: 1,
          eventId: createEventId(),
          type,
          systemId: host.systemId,
          seq: Date.now(),
          ts: new Date().toISOString(),
          payload: asMap(payload),
        };
        const encoded = JSON.stringify(event);
        try {
          runtime.socket.send(encoded);
        } catch (error) {
          addLog(`send failed (${host.displayName}): ${error}`);
          return false;
        }
        state.eventOut += 1;
        addLog(`OUT[${host.displayName}] ${encoded}`);
        return true;
      }

      function requestToolsRefresh(hostId) {
        sendSocketEvent(hostId, "tools_refresh_request", {});
      }

      function requestControllerRebind(hostId) {
        const host = hostById(hostId);
        if (!host) {
          addLog("重绑失败：未选择宿主机");
          return;
        }
        const runtime = ensureRuntime(hostId);
        if (!runtime || !runtime.connected) {
          addLog(`重绑失败：宿主机未连接 (${host.displayName})`);
          return;
        }
        const sent = sendSocketEvent(hostId, "controller_rebind_request", {
          deviceId: state.deviceId,
        });
        if (sent) {
          addLog(`已请求重绑控制端 (${host.displayName})`);
        }
      }

      function shouldAutoRebindByReason(reason) {
        const text = String(reason || "");
        return /未绑定控制设备|未被授权|未授权控制|控制设备/.test(text);
      }

      function connectCandidateTool(hostId, toolId) {
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);
        const id = String(toolId || "").trim();
        if (!host || !runtime || !id || runtime.connectingToolIds[id]) {
          return;
        }
        if (!runtime.connected) {
          addLog(`接入失败：宿主机未连接 (${host.displayName})`);
          return;
        }

        runtime.connectingToolIds[id] = true;
        clearToolConnectTimer(runtime, id);
        runtime.toolConnectTimers[id] = setTimeout(() => {
          const current = ensureRuntime(hostId);
          if (!current || !current.connectingToolIds[id]) {
            return;
          }
          delete current.connectingToolIds[id];
          delete current.toolConnectRetryCount[id];
          clearToolConnectTimer(current, id);
          renderAddToolModal();
          openHostNoticeModal(
            "工具接入未响应",
            `工具“${id}”接入超时。请确认 relay/sidecar 正常连接后重试；必要时先重连宿主机。`,
          );
        }, 5000);
        renderAddToolModal();

        const sent = sendSocketEvent(hostId, "tool_connect_request", { toolId: id });
        if (!sent) {
          delete runtime.connectingToolIds[id];
          delete runtime.toolConnectRetryCount[id];
          clearToolConnectTimer(runtime, id);
          render();
        }
      }

      function sendTestEvent() {
        const hostId = state.debugHostId;
        if (!hostId) {
          addLog("发送失败：请先选择调试宿主机");
          return;
        }
        sendSocketEvent(hostId, "chat_message", {
          text: state.message,
        });
        render();
      }

      function ingestEvent(hostId, raw) {
        const runtime = ensureRuntime(hostId);
        if (!runtime) {
          return;
        }

        try {
          const event = JSON.parse(raw);
          if (!event || typeof event !== "object") {
            return;
          }
          const type = String(event.type || "");
          const payload = asMap(event.payload);

          if (type === "heartbeat") {
            runtime.sidecarStatus = String(payload.status || "ONLINE");
            runtime.lastHeartbeatAt = new Date();
            runtime.status = runtime.connected ? "CONNECTED" : runtime.status;
            return;
          }

          if (type === "tools_snapshot") {
            const parsed = asListOfMap(payload.tools);
            runtime.tools = sanitizeTools(parsed);
            for (const tool of runtime.tools) {
              const toolId = String(tool.toolId || "");
              if (toolId) {
                delete runtime.connectingToolIds[toolId];
              }
            }
            return;
          }

          if (type === "tools_candidates") {
            const parsed = asListOfMap(payload.tools);
            runtime.candidateTools = sanitizeTools(parsed);
            return;
          }

          if (type === "tool_whitelist_updated") {
            const toolId = String(payload.toolId || "");
            const ok = asBool(payload.ok);
            const reason = String(payload.reason || "");
            if (toolId) {
              delete runtime.connectingToolIds[toolId];
              clearToolConnectTimer(runtime, toolId);
            }
            const host = hostById(hostId);
            if (!ok) {
              addLog(`接入工具失败 (${host ? host.displayName : hostId}): ${toolId || "--"} ${reason}`);
              const retryCount = Number(runtime.toolConnectRetryCount[toolId] || 0);
              if (toolId && shouldAutoRebindByReason(reason) && retryCount < 1) {
                runtime.toolConnectRetryCount[toolId] = retryCount + 1;
                requestControllerRebind(hostId);
                addLog(`检测到控制端权限限制，已自动重绑并重试 (${host ? host.displayName : hostId}): ${toolId}`);
                setTimeout(() => connectCandidateTool(hostId, toolId), 300);
              } else {
                if (toolId) {
                  delete runtime.toolConnectRetryCount[toolId];
                }
                openHostNoticeModal(
                  "工具接入失败",
                  reason || "sidecar 未接受本次接入请求，请检查宿主机连接状态后重试。",
                );
              }
            } else if (toolId) {
              delete runtime.toolConnectRetryCount[toolId];
              addLog(`工具白名单已更新 (${host ? host.displayName : hostId}): ${toolId}`);
              requestToolsRefresh(hostId);
            }
            renderAddToolModal();
            return;
          }

          if (type === "controller_bind_updated") {
            const ok = asBool(payload.ok);
            const changed = asBool(payload.changed);
            const deviceId = String(payload.deviceId || "--");
            const reason = String(payload.reason || "");
            const host = hostById(hostId);
            if (!ok) {
              addLog(`控制端重绑失败 (${host ? host.displayName : hostId}): ${deviceId} ${reason}`);
            } else if (changed) {
              addLog(`控制端已切换为当前设备 (${host ? host.displayName : hostId}): ${deviceId}`);
            } else {
              addLog(`控制端已是当前设备 (${host ? host.displayName : hostId}): ${deviceId}`);
            }
            return;
          }

          if (type !== "metrics_snapshot") {
            return;
          }

          runtime.systemMetrics = asMap(payload.system);
          runtime.sidecarMetrics = asMap(payload.sidecar);
          runtime.primaryToolMetrics = asMap(payload.tool);

          const metricsByToolId = {};
          const metricsTools = asListOfMap(payload.tools);
          for (const item of metricsTools) {
            const toolId = String(item.toolId || "");
            if (toolId) {
              metricsByToolId[toolId] = item;
            }
          }

          const primaryToolId = String(runtime.primaryToolMetrics.toolId || "");
          if (primaryToolId) {
            metricsByToolId[primaryToolId] = runtime.primaryToolMetrics;
          }
          runtime.toolMetricsById = metricsByToolId;

          if (runtime.tools.length === 0) {
            if (metricsTools.length > 0) {
              runtime.tools = sanitizeTools(metricsTools);
            } else if (primaryToolId) {
              runtime.tools = sanitizeTools([
                {
                  toolId: primaryToolId,
                  name: String(runtime.primaryToolMetrics.name || "Unknown Tool"),
                  category: String(runtime.primaryToolMetrics.category || "UNKNOWN"),
                  vendor: String(runtime.primaryToolMetrics.vendor || "-"),
                  mode: String(runtime.primaryToolMetrics.mode || "-"),
                  status: String(runtime.primaryToolMetrics.status || "RUNNING"),
                  connected: runtime.primaryToolMetrics.connected,
                  endpoint: String(runtime.primaryToolMetrics.endpoint || ""),
                  reason: String(runtime.primaryToolMetrics.reason || ""),
                },
              ]);
            }
          }
        } catch (_) {
          // ignore invalid payload
        }
      }

      function sanitizeTools(source) {
        return source.filter((tool) => {
          const name = String(tool.name || "").toLowerCase();
          const category = String(tool.category || "").toLowerCase();
          if (name.includes("mobile") || name.includes("client app")) {
            return false;
          }
          if (category.includes("client")) {
            return false;
          }
          return true;
        });
      }

      function metricForTool(hostId, toolId) {
        const runtime = ensureRuntime(hostId);
        if (!runtime || !toolId) {
          return {};
        }
        if (runtime.toolMetricsById[toolId]) {
          return runtime.toolMetricsById[toolId];
        }
        if (runtime.primaryToolMetrics.toolId === toolId) {
          return runtime.primaryToolMetrics;
        }
        return {};
      }

      function hostStatusLabel(hostId) {
        const runtime = ensureRuntime(hostId);
        if (!runtime) {
          return "离线";
        }
        if (runtime.connecting) {
          return "连接中";
        }
        if (runtime.connected) {
          return runtime.sidecarStatus === "ONLINE" ? "在线" : runtime.sidecarStatus;
        }
        if (runtime.manualReconnectRequired) {
          return "需手动重连";
        }
        if (runtime.status === "AUTH_EXPIRED") {
          return "凭证失效";
        }
        if (runtime.status === "RELAY_UNREACHABLE") {
          return "Relay 不可达";
        }
        return "离线";
      }

      function isAnyHostConnected() {
        return visibleHosts().some((host) => {
          const runtime = ensureRuntime(host.hostId);
          return runtime && runtime.connected;
        });
      }

      function hasConnectableHost() {
        return visibleHosts().some((host) => {
          const runtime = ensureRuntime(host.hostId);
          return runtime && !runtime.connected && !runtime.connecting;
        });
      }

      function render() {
        recomputeSelections();
        renderTabs();
        renderTopActions();
        renderHostStage();
        renderBanner();
        renderToolsGrouped();
        renderDebugPanel();
        renderToolModal();
        renderAddToolModal();
        renderHostManageModal();
      }

      function renderTabs() {
        const onOps = state.activeTab === "ops";
        ui.opsView.classList.toggle("active", onOps);
        ui.debugView.classList.toggle("active", !onOps);
        ui.tabOps.classList.toggle("active", onOps);
        ui.tabDebug.classList.toggle("active", !onOps);
      }

      function renderTopActions() {
        const hostCount = visibleHosts().length;
        ui.connectBtnTop.disabled = hostCount === 0 || !hasConnectableHost();
        ui.disconnectBtnTop.disabled = hostCount === 0 || !isAnyHostConnected();
        ui.replaceHostBtnTop.disabled = false;
      }

      function renderHostStage() {
        const hasHosts = visibleHosts().length > 0;
        ui.hostSetupCard.style.display = hasHosts ? "none" : "block";
        ui.hostOverviewWrap.classList.toggle("hidden", !hasHosts);
      }

      function renderBanner() {
        const hosts = visibleHosts();
        if (hosts.length === 0) {
          ui.hostBannerTrack.innerHTML = '<div class="empty">暂无已配对宿主机。</div>';
          ui.hostBannerDots.innerHTML = "";
          return;
        }

        const previousScroll = ui.hostBannerTrack.scrollLeft;
        ui.hostBannerTrack.innerHTML = hosts
          .map((host) => {
            const status = hostStatusLabel(host.hostId);
            const statusClass = status === "在线" ? "online" : "offline";
            return `
              <article class="host-banner-card" data-banner-host-id="${escapeHtml(host.hostId)}">
                <div class="host-banner-name">${escapeHtml(host.displayName)}</div>
                <div class="host-banner-status">
                  <span class="host-status-light ${statusClass}"></span>
                  ${escapeHtml(status)}
                </div>
              </article>
            `;
          })
          .join("");

        // Banner 仅用于展示与滑动索引提示，不承载点击行为。
        ui.hostBannerTrack.scrollLeft = previousScroll;
        renderBannerDots(hosts.length, state.bannerActiveIndex);
      }

      function renderBannerDots(count, activeIndex) {
        if (count <= 0) {
          ui.hostBannerDots.innerHTML = "";
          return;
        }
        const safeIndex = Math.min(Math.max(0, activeIndex), count - 1);
        ui.hostBannerDots.innerHTML = Array.from({ length: count })
          .map((_, idx) => `<span class="host-banner-dot ${idx === safeIndex ? "active" : ""}"></span>`)
          .join("");
      }

      function onHostBannerScroll() {
        const cards = Array.from(ui.hostBannerTrack.querySelectorAll(".host-banner-card"));
        if (cards.length === 0) {
          return;
        }
        const center = ui.hostBannerTrack.scrollLeft + ui.hostBannerTrack.clientWidth / 2;
        let bestIdx = 0;
        let bestDiff = Number.POSITIVE_INFINITY;
        cards.forEach((card, idx) => {
          const cardCenter = card.offsetLeft + card.offsetWidth / 2;
          const diff = Math.abs(cardCenter - center);
          if (diff < bestDiff) {
            bestDiff = diff;
            bestIdx = idx;
          }
        });
        if (bestIdx !== state.bannerActiveIndex) {
          state.bannerActiveIndex = bestIdx;
          renderBannerDots(cards.length, state.bannerActiveIndex);
        }
      }

      function renderToolsGrouped() {
        const hosts = visibleHosts();
        if (hosts.length === 0) {
          ui.toolsGroupedList.innerHTML = '<div class="empty">暂无宿主机，请先完成配对。</div>';
          return;
        }

        ui.toolsGroupedList.innerHTML = hosts
          .map((host) => renderHostGroup(host))
          .join("");
      }

      function renderHostGroup(host) {
        const runtime = ensureRuntime(host.hostId);
        const status = hostStatusLabel(host.hostId);
        const canAddTool = runtime && runtime.connected;
        const toolCards = renderHostTools(host.hostId);

        return `
          <article class="host-group" data-host-group-id="${escapeHtml(host.hostId)}">
            <div class="host-group-head">
              <div class="host-group-title">${escapeHtml(host.displayName)}</div>
              <span class="host-status-chip">${escapeHtml(status)}</span>
            </div>
            <div class="host-group-actions" style="grid-template-columns: 1fr">
              <button class="btn btn-outline btn-sm" data-host-add-tool="${escapeHtml(host.hostId)}" ${canAddTool ? "" : "disabled"}>+ 工具</button>
            </div>
            <div class="host-group-tools">
              ${toolCards}
            </div>
          </article>
        `;
      }

      function renderHostTools(hostId) {
        const runtime = ensureRuntime(hostId);
        if (!runtime || runtime.tools.length === 0) {
          return '<div class="empty">该宿主机暂无已接入工具。</div>';
        }

        return runtime.tools
          .map((tool) => {
            const toolId = String(tool.toolId || "");
            const metric = metricForTool(hostId, toolId);
            if (isOpenCodeTool(tool)) {
              return renderOpenCodeCard(hostId, tool, metric);
            }
            return renderGenericCard(hostId, tool, metric);
          })
          .join("");
      }

      function onToolsGroupedClick(event) {
        const connectBtn = event.target.closest("[data-host-connect]");
        if (connectBtn) {
          const hostId = String(connectBtn.getAttribute("data-host-connect") || "");
          const runtime = ensureRuntime(hostId);
          if (runtime && runtime.connected) {
            void reconnectHost(hostId);
          } else {
            void connectHost(hostId, { manual: true, resetRetry: true });
          }
          return;
        }

        const disconnectBtn = event.target.closest("[data-host-disconnect]");
        if (disconnectBtn) {
          const hostId = String(disconnectBtn.getAttribute("data-host-disconnect") || "");
          void disconnectHost(hostId, { triggerReconnect: true });
          return;
        }

        const addToolBtn = event.target.closest("[data-host-add-tool]");
        if (addToolBtn) {
          const hostId = String(addToolBtn.getAttribute("data-host-add-tool") || "");
          openAddToolModal(hostId);
          return;
        }

        const manualReconnectBtn = event.target.closest("[data-host-manual-reconnect]");
        if (manualReconnectBtn) {
          const hostId = String(manualReconnectBtn.getAttribute("data-host-manual-reconnect") || "");
          const runtime = ensureRuntime(hostId);
          if (runtime) {
            runtime.manualReconnectRequired = false;
            runtime.retryCount = 0;
          }
          void connectHost(hostId, { manual: true, resetRetry: true });
          return;
        }

        const manageBtn = event.target.closest("[data-host-open-manage]");
        if (manageBtn) {
          openHostManageModal();
          return;
        }

        const card = event.target.closest("[data-host-id][data-tool-id]");
        if (!card) {
          return;
        }
        const hostId = String(card.getAttribute("data-host-id") || "");
        const toolId = String(card.getAttribute("data-tool-id") || "");
        openToolDetail(hostId, toolId);
      }

      function openAddToolModal(hostId) {
        const host = hostById(hostId);
        if (!host) {
          return;
        }
        state.addToolHostId = hostId;
        ui.addToolModal.classList.add("show");
        requestToolsRefresh(hostId);
        renderAddToolModal();
      }

      function closeAddToolModal() {
        ui.addToolModal.classList.remove("show");
        state.addToolHostId = "";
      }

      function onCandidateListClick(event) {
        const btn = event.target.closest("[data-connect-tool-id]");
        if (!btn) {
          return;
        }
        const toolId = String(btn.getAttribute("data-connect-tool-id") || "");
        if (!state.addToolHostId) {
          return;
        }
        connectCandidateTool(state.addToolHostId, toolId);
        renderAddToolModal();
      }

      function renderAddToolModal() {
        if (!ui.addToolModal.classList.contains("show")) {
          return;
        }

        const host = hostById(state.addToolHostId);
        const runtime = ensureRuntime(state.addToolHostId);
        if (!host || !runtime) {
          ui.candidateList.innerHTML = '<div class="empty">未找到宿主机，请重新打开。</div>';
          return;
        }

        if (!runtime.connected) {
          ui.candidateList.innerHTML = '<div class="empty">请先连接该宿主机，再添加工具。</div>';
          return;
        }

        if (runtime.candidateTools.length === 0) {
          if (runtime.tools.length > 0) {
            ui.candidateList.innerHTML =
              '<div class="empty">当前没有候选工具。已发现的工具可能已接入（候选列表仅展示未接入工具）。</div>';
          } else {
            ui.candidateList.innerHTML =
              '<div class="empty">当前没有候选工具。请确认宿主机已运行 opencode/openclaw，并等待一次快照刷新。</div>';
          }
          return;
        }

        ui.candidateList.innerHTML = runtime.candidateTools
          .map((tool) => {
            const toolId = String(tool.toolId || "");
            const connecting = asBool(runtime.connectingToolIds[toolId]);
            const reason = String(tool.reason || "已发现可接入进程");
            return `
              <article class="candidate-item">
                <div class="candidate-head">
                  <div class="candidate-title">${escapeHtml(String(tool.name || "Unknown Tool"))}</div>
                  <span class="chip">${escapeHtml(localizedCategory(tool.category))}</span>
                  <div class="candidate-actions">
                    <button class="btn btn-primary btn-sm" data-connect-tool-id="${escapeHtml(toolId)}" ${connecting ? "disabled" : ""}>
                      ${connecting ? "接入中..." : "接入"}
                    </button>
                  </div>
                </div>
                <div class="candidate-meta">${escapeHtml(reason)}</div>
              </article>
            `;
          })
          .join("");
      }

      function renderDebugPanel() {
        const hosts = visibleHosts();
        const hostId = state.debugHostId;
        const host = hostById(hostId);
        const runtime = ensureRuntime(hostId);

        ui.debugHostSelect.innerHTML = hosts
          .map((item) => `<option value="${escapeHtml(item.hostId)}" ${item.hostId === hostId ? "selected" : ""}>${escapeHtml(item.displayName)}</option>`)
          .join("");

        const status = runtime && runtime.connected ? "Connected" : runtime && runtime.connecting ? "Connecting" : "Disconnected";
        ui.debugStatus.textContent = `Status: ${status}`;
        ui.debugEvents.textContent = `Events IN: ${state.eventIn} · OUT: ${state.eventOut}`;
        ui.debugIdentity.textContent =
          `Host: ${host ? host.displayName : "--"} · System: ${host ? host.systemId : "--"} · ` +
          `AccessToken: ${maskSecret(runtime ? runtime.accessToken : "")} · Device: ${state.deviceId || "--"}`;

        ui.connectBtnDebug.disabled = !host || (runtime && (runtime.connected || runtime.connecting));
        ui.disconnectBtnDebug.disabled = !host || !(runtime && runtime.connected);
        ui.rebindControllerBtn.disabled = !host || !(runtime && runtime.connected);

        ui.logBox.innerHTML = state.logs.map((line) => `<div class="log-item">${escapeHtml(line)}</div>`).join("");
        if (document.activeElement !== ui.messageInput) {
          ui.messageInput.value = state.message;
        }
      }

      function renderOpenCodeCard(hostId, tool, metric) {
        const mode = String(metric.mode ?? tool.mode ?? "TUI");
        const endpoint = String(metric.endpoint ?? tool.endpoint ?? "");
        const reason = String(metric.reason ?? tool.reason ?? "");
        const connected = asBool(metric.connected ?? tool.connected);
        const status = String(metric.status ?? tool.status ?? "UNKNOWN");
        const note = endpoint || reason || "等待会话信息同步...";

        return `
          <article class="tool-card tool-opencode" data-host-id="${escapeHtml(hostId)}" data-tool-id="${escapeHtml(String(tool.toolId || ""))}">
            <div class="tool-head">
              <div class="tool-logo">OC</div>
              <div class="tool-name">OpenCode</div>
              <span class="chip">${escapeHtml(mode.toUpperCase())}</span>
            </div>
            <div class="chip-wrap">
              <span class="chip">${escapeHtml(status)}</span>
              <span class="chip">${connected ? "已接入" : "未接入"}</span>
            </div>
            <p class="tool-note">${escapeHtml(note)}</p>
            <div class="tool-metrics">
              <div class="tool-metric">
                <div class="name">CPU</div>
                <div class="value">${escapeHtml(fmt2(metric.cpuPercent))}%</div>
              </div>
              <div class="tool-metric">
                <div class="name">Memory</div>
                <div class="value">${escapeHtml(fmt2(metric.memoryMb))} MB</div>
              </div>
            </div>
          </article>
        `;
      }

      function renderGenericCard(hostId, tool, metric) {
        return `
          <article class="tool-card tool-generic" data-host-id="${escapeHtml(hostId)}" data-tool-id="${escapeHtml(String(tool.toolId || ""))}">
            <div class="bar"></div>
            <div>
              <div class="title">${escapeHtml(String(tool.name || "Unknown Tool"))}</div>
              <div class="sub">${escapeHtml(localizedCategory(tool.category))} · ${escapeHtml(String(tool.status || "-"))}</div>
            </div>
            <div class="right">
              <div>${escapeHtml(fmt2(metric.cpuPercent))}% CPU</div>
              <div class="sub">${escapeHtml(fmt2(metric.memoryMb))} MB</div>
            </div>
          </article>
        `;
      }

      function isOpenCodeTool(tool) {
        const toolId = String(tool.toolId || "").toLowerCase();
        const name = String(tool.name || "").toLowerCase();
        const vendor = String(tool.vendor || "").toLowerCase();
        return toolId.startsWith("opencode_") || name.includes("opencode") || vendor.includes("opencode");
      }

      function openToolDetail(hostId, toolId) {
        if (!hostId || !toolId) {
          return;
        }
        state.detailHostId = hostId;
        state.detailToolId = toolId;
        state.detailExpanded = false;
        renderToolModal();
      }

      function closeToolDetail() {
        state.detailHostId = "";
        state.detailToolId = "";
        state.detailExpanded = false;
        renderToolModal();
      }

      function renderToolModal() {
        if (!state.detailHostId || !state.detailToolId) {
          ui.toolModal.classList.remove("show");
          return;
        }

        const host = hostById(state.detailHostId);
        const runtime = ensureRuntime(state.detailHostId);
        if (!host || !runtime) {
          ui.toolModal.classList.remove("show");
          return;
        }

        const tool = runtime.tools.find((item) => String(item.toolId || "") === state.detailToolId);
        if (!tool) {
          ui.toolModal.classList.remove("show");
          return;
        }

        const metric = metricForTool(state.detailHostId, String(tool.toolId || ""));
        const pick = (key) => {
          const value = metric[key] ?? tool[key];
          return value == null ? "" : String(value);
        };

        const toolId = String(tool.toolId || "");
        const endpoint = pick("endpoint");
        const mode = pick("mode");
        const status = pick("status");
        const reason = pick("reason");
        const vendor = pick("vendor");
        const workspaceDir = pick("workspaceDir");
        const sessionId = pick("sessionId");
        const sessionTitle = pick("sessionTitle");
        const sessionUpdatedAt = pick("sessionUpdatedAt");
        const agentMode = pick("agentMode");
        const model = pick("model");

        const connectedTool = asBool(metric.connected ?? tool.connected);
        const latestTokens = asMap(metric.latestTokens);
        const modelUsage = asListOfMap(metric.modelUsage);

        const summaryRows = [
          ["宿主机", host.displayName],
          ["工具模式", mode || "--"],
          ["会话模式", agentMode || "--"],
          ["当前模型", model || "--"],
          ["状态", status || "--"],
          [
            "最近Token（总/输入/输出）",
            `${fmtTokenM(latestTokens.total)} / ${fmtTokenM(latestTokens.input)} / ${fmtTokenM(latestTokens.output)}`,
          ],
          [
            "最近缓存（读/写）",
            `${fmtTokenM(latestTokens.cacheRead)} / ${fmtTokenM(latestTokens.cacheWrite)}`,
          ],
          ["模型用量", usageSummary(modelUsage)],
        ];
        if (reason) {
          summaryRows.push(["原因", reason]);
        }

        const detailsRows = [
          ["App Link", runtime.connected ? "Connected" : "Disconnected"],
          ["Last Heartbeat", runtime.lastHeartbeatAt ? runtime.lastHeartbeatAt.toLocaleString() : "--"],
          ["Tool Reachable", connectedTool ? "Yes" : "No"],
          ["Tool ID", toolId || "--"],
          ["Endpoint", endpoint || "--"],
          ["Workspace", workspaceDir || "--"],
          ["Session ID", sessionId || "--"],
          ["Session Title", sessionTitle || "--"],
          ["Session Updated", sessionUpdatedAt || "--"],
          ["厂商", vendor || "--"],
          ["类别", localizedCategory(tool.category)],
          ["CPU", `${fmt2(metric.cpuPercent)}%`],
          ["Memory", `${fmt2(metric.memoryMb)} MB`],
          ["Source", String(metric.source || "--")],
          ["Latest Cache", `R:${fmtTokenM(latestTokens.cacheRead)} W:${fmtTokenM(latestTokens.cacheWrite)}`],
        ];

        ui.toolModalTitle.textContent = String(tool.name || "Tool Detail");
        ui.summaryRows.innerHTML = renderRows(summaryRows);

        const previewCount = 2;
        const showingRows = state.detailExpanded ? detailsRows : detailsRows.slice(0, previewCount);
        ui.detailRows.innerHTML = renderRows(showingRows);
        ui.detailTip.textContent =
          !state.detailExpanded && detailsRows.length > previewCount
            ? `还有 ${detailsRows.length - previewCount} 项，点击箭头展开`
            : "";

        ui.toggleDetailsBtn.textContent = state.detailExpanded ? "⌃" : "⌄";

        if (state.detailExpanded && modelUsage.length > 0) {
          ui.usagePanel.style.display = "block";
          ui.usageRows.innerHTML = renderRows(
            modelUsage.map((row) => {
              const modelName = String(row.model || "--");
              const total = fmtTokenM(row.tokenTotal);
              const input = fmtTokenM(row.tokenInput);
              const output = fmtTokenM(row.tokenOutput);
              const count = fmtInt(row.messages);
              return [modelName, `消息 ${count} 条 · 总Token ${total} · 输入 ${input} · 输出 ${output}`];
            }),
          );
        } else {
          ui.usagePanel.style.display = "none";
          ui.usageRows.innerHTML = "";
        }

        ui.toolModal.classList.add("show");
      }

      function openHostManageModal() {
        ui.hostManageModal.classList.add("show");
        renderHostManageModal();
      }

      function closeHostManageModal() {
        ui.hostManageModal.classList.remove("show");
      }

      function renderHostManageModal() {
        if (!ui.hostManageModal.classList.contains("show")) {
          return;
        }

        const hosts = visibleHosts();
        if (hosts.length === 0) {
          ui.hostManageList.innerHTML = '<div class="empty">暂无已配对宿主机。</div>';
        } else {
          ui.hostManageList.innerHTML = hosts
            .map((host) => {
              const runtime = ensureRuntime(host.hostId);
              const status = hostStatusLabel(host.hostId);
              const note = host.note ? ` · 备注: ${host.note}` : "";
              const connectLabel = runtime && runtime.connected ? "重连" : runtime && runtime.connecting ? "连接中" : "连接";
              return `
                <article class="host-manage-item">
                  <div class="host-manage-name">${escapeHtml(host.displayName)}</div>
                  <div class="host-manage-sub">状态: ${escapeHtml(status)}${escapeHtml(note)}</div>
                  <div class="host-manage-actions">
                    <button class="btn btn-primary btn-sm" data-manage-connect="${escapeHtml(host.hostId)}">${escapeHtml(connectLabel)}</button>
                    <button class="btn btn-outline btn-sm" data-manage-disconnect="${escapeHtml(host.hostId)}">断开</button>
                    <button class="btn btn-outline btn-sm" data-manage-edit="${escapeHtml(host.hostId)}">编辑</button>
                    <button class="btn btn-outline btn-sm" data-manage-repair="${escapeHtml(host.hostId)}">重新配对</button>
                    <button class="btn btn-outline btn-sm" data-manage-delete="${escapeHtml(host.hostId)}">删除</button>
                    <button class="btn btn-outline btn-sm" data-manage-open-debug="${escapeHtml(host.hostId)}">调试此宿主机</button>
                  </div>
                </article>
              `;
            })
            .join("");
        }

        if (state.pendingHostDeletes.length === 0) {
          ui.pendingDeleteList.innerHTML = '<div class="empty">当前无删除补偿任务。</div>';
        } else {
          ui.pendingDeleteList.innerHTML = state.pendingHostDeletes
            .map((item) => {
              const retryAt = new Date(Number(item.nextRetryAt || 0));
              return `
                <article class="host-manage-item">
                  <div class="host-manage-name">${escapeHtml(item.displayName || item.systemId)}</div>
                  <div class="host-manage-sub">
                    删除处理中 · 重试 ${escapeHtml(String(item.retryCount || 0))} 次 · 下次: ${escapeHtml(
                      Number.isFinite(retryAt.getTime()) ? retryAt.toLocaleString() : "--",
                    )}
                  </div>
                  <div class="host-manage-sub">最近错误: ${escapeHtml(item.lastError || "--")}</div>
                  <div class="host-manage-actions" style="grid-template-columns: 1fr">
                    <button class="btn btn-outline btn-sm" data-pending-retry="${escapeHtml(item.hostId)}">立即重试删除</button>
                  </div>
                </article>
              `;
            })
            .join("");
        }
      }

      function onHostManageListClick(event) {
        const connectBtn = event.target.closest("[data-manage-connect]");
        if (connectBtn) {
          const hostId = String(connectBtn.getAttribute("data-manage-connect") || "");
          const runtime = ensureRuntime(hostId);
          if (runtime && runtime.connected) {
            void reconnectHost(hostId);
          } else {
            void connectHost(hostId, { manual: true, resetRetry: true });
          }
          return;
        }

        const disconnectBtn = event.target.closest("[data-manage-disconnect]");
        if (disconnectBtn) {
          const hostId = String(disconnectBtn.getAttribute("data-manage-disconnect") || "");
          void disconnectHost(hostId, { triggerReconnect: true });
          return;
        }

        const editBtn = event.target.closest("[data-manage-edit]");
        if (editBtn) {
          const hostId = String(editBtn.getAttribute("data-manage-edit") || "");
          openHostEditModal(hostId);
          return;
        }

        const repairBtn = event.target.closest("[data-manage-repair]");
        if (repairBtn) {
          const hostId = String(repairBtn.getAttribute("data-manage-repair") || "");
          closeHostManageModal();
          openPairFlow("import", hostId);
          return;
        }

        const deleteBtn = event.target.closest("[data-manage-delete]");
        if (deleteBtn) {
          const hostId = String(deleteBtn.getAttribute("data-manage-delete") || "");
          void deleteHostWithCompensation(hostId);
          return;
        }

        const debugBtn = event.target.closest("[data-manage-open-debug]");
        if (debugBtn) {
          state.debugHostId = String(debugBtn.getAttribute("data-manage-open-debug") || "");
          state.activeTab = "debug";
          closeHostManageModal();
          render();
        }
      }

      function onPendingDeleteListClick(event) {
        const retryBtn = event.target.closest("[data-pending-retry]");
        if (!retryBtn) {
          return;
        }
        const hostId = String(retryBtn.getAttribute("data-pending-retry") || "");
        void retryPendingDelete(hostId, true);
      }

      function openHostEditModal(hostId) {
        const host = hostById(hostId);
        if (!host) {
          return;
        }
        state.editingHostId = hostId;
        ui.hostEditNameInput.value = host.displayName || "";
        ui.hostEditNoteInput.value = host.note || "";
        ui.hostEditModal.classList.add("show");
      }

      function closeHostEditModal() {
        ui.hostEditModal.classList.remove("show");
        state.editingHostId = "";
      }

      function saveHostEdit() {
        const host = hostById(state.editingHostId);
        if (!host) {
          closeHostEditModal();
          return;
        }

        const newName = String(ui.hostEditNameInput.value || "").trim();
        const newNote = String(ui.hostEditNoteInput.value || "").trim();
        host.displayName = newName || host.systemId;
        host.note = newNote;
        host.updatedAt = new Date().toISOString();

        persistConfig();
        closeHostEditModal();
        notifyIfDuplicateDisplayName(host.hostId);
        render();
      }

      function openHostNoticeModal(title, body, targetHostId = "") {
        ui.hostNoticeTitle.textContent = title;
        ui.hostNoticeBody.textContent = body;
        state.hostNoticeTargetId = String(targetHostId || "");
        ui.hostNoticeModal.classList.add("show");
      }

      function closeHostNoticeModal() {
        ui.hostNoticeModal.classList.remove("show");
        state.hostNoticeTargetId = "";
      }

      function notifyIfDuplicateDisplayName(hostId) {
        const host = hostById(hostId);
        if (!host) {
          return;
        }
        const sameNameHosts = visibleHosts().filter((item) => item.displayName === host.displayName);
        if (sameNameHosts.length <= 1) {
          return;
        }

        const suggested = `${host.displayName}-${shortSystemId(host.systemId)}`;
        openHostNoticeModal(
          "宿主机名称重复",
          `检测到多个宿主机使用同名“${host.displayName}”。建议改名为“${suggested}”便于识别，不影响当前连接。`,
          hostId,
        );
      }

      function shortSystemId(systemId) {
        const raw = String(systemId || "").trim();
        if (!raw) {
          return "host";
        }
        return raw.length <= 8 ? raw : raw.slice(0, 8);
      }

      async function deleteHostWithCompensation(hostId) {
        const host = hostById(hostId);
        if (!host) {
          return;
        }

        const confirmed = window.confirm(`确认删除宿主机“${host.displayName}”？\n删除后将吊销当前设备凭证并清理本地配置。`);
        if (!confirmed) {
          return;
        }

        let expectedCredentialId = "";
        let expectedKeyId = "";
        try {
          const session = await tauriInvoke("auth_load_session", {
            systemId: host.systemId,
            deviceId: state.deviceId,
          });
          if (session) {
            expectedCredentialId = String(session.credentialId || "").trim();
            expectedKeyId = String(session.keyId || "").trim();
          }
        } catch (error) {
          addLog(`delete preload session failed (${host.displayName}): ${error}`);
        }

        // 从主视图移除并写入补偿队列，保证页面即时隐藏。
        state.hosts = state.hosts.filter((item) => item.hostId !== hostId);
        disposeRuntime(hostId);

        state.pendingHostDeletes.push({
          hostId: host.hostId,
          systemId: host.systemId,
          relayUrl: host.relayUrl,
          displayName: host.displayName,
          deviceId: state.deviceId,
          enqueuedAt: Date.now(),
          retryCount: 0,
          nextRetryAt: Date.now(),
          lastError: "",
          expectedCredentialId,
          expectedKeyId,
        });

        recomputeSelections();
        persistConfig();
        render();

        openHostNoticeModal(
          "删除任务已接收",
          "当前 Relay 可能不可达。系统将在可连接 Relay 后自动执行删除；该宿主机已从主页面隐藏。",
        );

        await retryPendingDelete(hostId, true);
      }

      async function processPendingDeletes() {
        if (state.deleteCompensating) {
          return;
        }
        if (state.pendingHostDeletes.length === 0) {
          return;
        }
        state.deleteCompensating = true;
        try {
          const now = Date.now();
          const due = state.pendingHostDeletes.filter((item) => Number(item.nextRetryAt || 0) <= now);
          for (const item of due) {
            await retryPendingDelete(item.hostId, false);
          }
        } finally {
          state.deleteCompensating = false;
        }
      }

      async function retryPendingDelete(hostId, manual) {
        const index = state.pendingHostDeletes.findIndex((item) => item.hostId === hostId);
        if (index < 0) {
          return;
        }
        const item = state.pendingHostDeletes[index];

        try {
          await revokeAndClearPendingHost(item);
          state.pendingHostDeletes.splice(index, 1);
          persistConfig();
          addLog(`删除补偿完成: ${item.displayName}`);
          if (manual) {
            openHostNoticeModal("删除完成", `宿主机“${item.displayName}”已完成最终删除。`);
          }
          render();
        } catch (error) {
          const errorCode = String(error && error.code ? error.code : "");
          if (errorCode === "DELETE_COMPENSATION_STALE") {
            state.pendingHostDeletes.splice(index, 1);
            persistConfig();
            addLog(`删除补偿已跳过(${item.displayName})：检测到宿主机已重新配对，避免误吊销新会话`);
            if (manual) {
              openHostNoticeModal(
                "删除任务已取消",
                `检测到宿主机“${item.displayName}”已重新配对，旧删除任务已自动取消。`,
              );
            }
            render();
            return;
          }

          item.retryCount = Number(item.retryCount || 0) + 1;
          item.nextRetryAt = Date.now() + DELETE_RETRY_INTERVAL_MS;
          item.lastError = String(error || "revoke failed");
          persistConfig();
          addLog(`删除补偿失败(${item.displayName}) #${item.retryCount}: ${item.lastError}`);
          if (manual) {
            openHostNoticeModal(
              "删除暂未完成",
              `Relay 暂不可达或鉴权失败：${item.lastError}。系统会继续自动补偿删除。`,
            );
          }
          renderHostManageModal();
        }
      }

      async function revokeAndClearPendingHost(item) {
        const session = await tauriInvoke("auth_load_session", {
          systemId: item.systemId,
          deviceId: state.deviceId,
        });
        if (!session) {
          throw new Error("本地设备凭证不存在");
        }

        const currentCredentialId = String(session.credentialId || "").trim();
        const expectedCredentialId = String(item.expectedCredentialId || "").trim();
        const currentKeyId = String(session.keyId || "").trim();
        const expectedKeyId = String(item.expectedKeyId || "").trim();
        if (
          (expectedCredentialId && currentCredentialId && expectedCredentialId !== currentCredentialId) ||
          (expectedKeyId && currentKeyId && expectedKeyId !== currentKeyId)
        ) {
          const err = new Error("stale pending delete");
          err.code = "DELETE_COMPENSATION_STALE";
          throw err;
        }

        const hostRuntime = createRuntime();
        hostRuntime.accessToken = String(session.accessToken || "");
        hostRuntime.refreshToken = String(session.refreshToken || "");
        hostRuntime.keyId = String(session.keyId || "");
        hostRuntime.credentialId = String(session.credentialId || "");

        if (!hostRuntime.accessToken || !hostRuntime.refreshToken || !hostRuntime.keyId) {
          throw new Error("设备凭证不完整");
        }

        await refreshPendingSessionIfPossible(item, hostRuntime);

        const ts = String(Math.floor(Date.now() / 1000));
        const nonce = createEventId();
        const payload = `auth-revoke\n${item.systemId}\n${state.deviceId}\n${state.deviceId}\n${hostRuntime.keyId}\n${ts}\n${nonce}`;
        const signed = await tauriInvoke("auth_sign_payload", {
          deviceId: state.deviceId,
          payload,
        });

        const { resp, body } = await relayRequestJson(item.relayUrl, "/auth/revoke-device", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            systemId: item.systemId,
            deviceId: state.deviceId,
            targetDeviceId: state.deviceId,
            accessToken: hostRuntime.accessToken,
            keyId: String(signed.keyId || hostRuntime.keyId),
            ts,
            nonce,
            sig: String(signed.signature || ""),
          }),
        });
        if (!resp.ok || !body.ok) {
          throw new Error(`${body.code || resp.status} ${body.message || "吊销失败"}`);
        }

        await clearHostSession(item.systemId);
      }

      async function refreshPendingSessionIfPossible(item, runtimeLike) {
        if (!runtimeLike.refreshToken || !runtimeLike.keyId) {
          return false;
        }

        const ts = String(Math.floor(Date.now() / 1000));
        const nonce = createEventId();
        const payload = `auth-refresh\n${item.systemId}\n${state.deviceId}\n${runtimeLike.keyId}\n${ts}\n${nonce}`;
        const signed = await tauriInvoke("auth_sign_payload", {
          deviceId: state.deviceId,
          payload,
        });

        const { resp, body } = await relayRequestJson(item.relayUrl, "/auth/refresh", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            systemId: item.systemId,
            deviceId: state.deviceId,
            refreshToken: runtimeLike.refreshToken,
            keyId: String(signed.keyId || runtimeLike.keyId),
            ts,
            nonce,
            sig: String(signed.signature || ""),
          }),
        });

        if (!resp.ok || !body.ok) {
          return false;
        }

        const data = asMap(body.data);
        runtimeLike.accessToken = String(data.accessToken || runtimeLike.accessToken);
        runtimeLike.refreshToken = String(data.refreshToken || runtimeLike.refreshToken);
        runtimeLike.keyId = String(data.keyId || runtimeLike.keyId);
        runtimeLike.credentialId = String(data.credentialId || runtimeLike.credentialId);

        await tauriInvoke("auth_store_session", {
          session: {
            systemId: item.systemId,
            deviceId: state.deviceId,
            accessToken: runtimeLike.accessToken,
            refreshToken: runtimeLike.refreshToken,
            keyId: runtimeLike.keyId,
            credentialId: runtimeLike.credentialId,
          },
        });
        return true;
      }

      function renderRows(rows) {
        return rows
          .map(
            ([key, value]) => `
              <div class="row">
                <div class="k">${escapeHtml(String(key))}</div>
                <div class="v">${escapeHtml(String(value ?? "--"))}</div>
              </div>
            `,
          )
          .join("");
      }

      function usageSummary(usage) {
        if (!usage.length) {
          return "--";
        }
        return usage
          .slice(0, 2)
          .map((row) => {
            const model = String(row.model || "--");
            const total = fmtTokenM(row.tokenTotal);
            const count = fmtInt(row.messages);
            return `${model}（总Token ${total}，消息 ${count} 条）`;
          })
          .join(" | ");
      }

      function localizedCategory(rawValue) {
        const raw = String(rawValue || "");
        if (raw === "CODE_AGENT") {
          return "代码助手";
        }
        if (raw === "DEV_WORKER") {
          return "开发工具";
        }
        if (raw === "UNKNOWN") {
          return "未知";
        }
        return raw || "--";
      }

      function asMap(value) {
        return value && typeof value === "object" && !Array.isArray(value) ? value : {};
      }

      function asListOfMap(value) {
        if (!Array.isArray(value)) {
          return [];
        }
        return value.filter((item) => item && typeof item === "object" && !Array.isArray(item));
      }

      function asBool(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "number") {
          return value !== 0;
        }
        if (typeof value === "string") {
          const lower = value.toLowerCase();
          return lower === "1" || lower === "true" || lower === "yes" || lower === "on";
        }
        return false;
      }

      function fmt2(value) {
        return Number.isFinite(Number(value)) ? Number(value).toFixed(2) : "--";
      }

      function fmtInt(value) {
        return Number.isFinite(Number(value)) ? String(Math.trunc(Number(value))) : "--";
      }

      function fmtTokenM(value) {
        const raw = Number(value);
        if (!Number.isFinite(raw)) {
          return "--";
        }
        const million = raw / 1_000_000;
        const abs = Math.abs(million);
        let decimals = 2;
        if (abs >= 100) {
          decimals = 0;
        } else if (abs >= 10) {
          decimals = 1;
        } else if (abs >= 1) {
          decimals = 2;
        } else if (abs >= 0.1) {
          decimals = 3;
        } else if (abs >= 0.01) {
          decimals = 4;
        } else if (abs >= 0.001) {
          decimals = 5;
        } else {
          decimals = 6;
        }
        let formatted = million.toFixed(decimals).replace(/\.?0+$/, "");
        if (formatted === "-0") {
          formatted = "0";
        }
        return `${formatted}M`;
      }

      function maskSecret(value) {
        const raw = String(value || "");
        if (!raw) {
          return "--";
        }
        if (raw.length <= 8) {
          return "****";
        }
        return `${raw.slice(0, 4)}****${raw.slice(-4)}`;
      }

      function escapeHtml(value) {
        return String(value)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function addLog(text) {
        const line = `[${new Date().toISOString()}] ${text}`;
        state.logs.unshift(line);
        if (state.logs.length > 300) {
          state.logs.length = 300;
        }
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      init();
    </script>
  </body>
</html>
